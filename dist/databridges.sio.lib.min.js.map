{"version":3,"file":"databridges.sio.lib.min.js","sources":["../src/exception/errorMessages.js","../src/dispatcher/dispatcher.js","../src/Connection/states.js","../src/Utils/util.js","../src/msgTypes/dBMessageTypes.js","../src/Connection/ConectionState.js","../src/channel/channel.js","../src/channel/channelnbd.js","../src/channel/channelstatus.js","../src/channel/accessResponse.js","../src/channel/channels.js","../src/rpc/rpcResponse.js","../src/rpc/rpcclient.js","../src/rpc/rpcstatus.js","../src/rpc/rpcSResponse.js","../src/rpc/rpcCaller.js","../src/rpc/rpcaccessResponse.js","../src/rpc/rpc.js","../src/dbridges.js"],"sourcesContent":["/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n//version: 20220419\n//date:  19-04-2022\n\n\nconst errMsg =  { \n  \"E001\": [1,1],\n  \"E002\": [1,2],\n  \"E004\": [1,4],\n  \"E006\": [1,5],\n  \"E008\": [1,5],\n  \"E009\": [1,7],\n  \"E010\": [1,7],\n  \"E011\": [4,8],\n  \"E012\": [5,9],\n  \"E013\": [5,10],\n  \"E014\": [6,8],\n  \"E015\": [6,11],\n  \"E024\": [11,8],\n  \"E025\": [11,11],\n  \"E026\": [11,11],\n  \"E027\": [11,14],\n  \"E028\": [11,11],\n  \"E030\": [12,16],\n  \"E033\": [20,8],\n  \"E038\": [20,24],\n  \"E039\": [20,11],\n  \"E040\": [3,3],\n  \"E041\": [10,13],\n  \"E042\": [20,19],\n  \"E048\": [21,18],\n  \"E051\": [21,18],\n  \"E052\": [21,18],\n  \"E053\": [21,8],\n  \"E054\": [15,3],\n  \"E055\": [22,3],\n  \"E058\": [6,20],\n  \"E059\": [6,20],\n  \"E060\": [1,21],\n  \"E061\": [24,22],\n  \"E062\": [24,23],\n  \"E063\": [1,8],\n  \"E064\": [7,3],\n  \"E065\": [14,3],\n  \"E066\": [16,9],\n  \"E067\": [16,10],\n  \"E068\": [27,8],\n  \"E070\": [13,3],\n  \"E076\": [18,9],\n  \"E077\": [18,10],\n  \"E079\": [15,8],\n  \"E080\": [15,25],\n  \"E082\": [9,3],\n  \"E084\": [28,3],\n  \"E088\": [29,3],\n  \"E090\": [30,8],\n  \"E091\": [11,28],\n  \"E092\": [30,28],\n  \"E093\": [11,29],\n  \"E094\": [30,30],\n  \"E095\": [30,31],\n  \"E096\": [12,40],\n  \"E097\": [12,32],\n  \"E098\": [12,8],\n  \"E099\": [31,31],\n  \"E100\": [31,40],\n  \"E101\": [31,34],\n  \"E102\": [31,8],\n  \"E103\": [30,41],\n  \"E104\": [21,36],\n  \"E105\": [27,37],\n  \"E108\": [23,38],\n  \"E109\": [20,38],\n  \"E110\": [32,39],\n  \"E111\": [32,10]\n};\n  \nconst source_lookup = { \n  1:\"DBLIB_CONNECT\",\n  2:\"DBCFCALLEE_CF_CALL\",\n  3:\"DBNET_CHANNEL_CALL\",\n  4:\"DBLIB_RTTPING\",\n  5:\"DBLIB_CONNECT_BIND\",\n  6:\"DBLIB_CHANNEL_PUBLISH\",\n  7:\"DBNET_CHANNEL_SUBSCRIBE\",\n  8:\"DBNET_RPC_REGISTER\",\n  9:\"DBNET_RPC_CONNECT\",\n  10:\"DBRPCCALLEE_CHANNEL_CALL\",\n  11:\"DBLIB_CHANNEL_SUBSCRIBE\",\n  12:\"DBLIB_CHANNEL_UNSUBSCRIBE\",\n  13:\"DBNET_CF_CALL\",\n  14:\"DBNET_CHANNEL_UNSUBSCRIBE\",\n  15:\"DBNET_RPC_CALL\",\n  16:\"DBLIB_CF_BIND\",\n  17:\"DBLIB_RPC_BIND\",\n  18:\"DBLIB_RPC_CALLER\",\n  19:\"DBLIB_CHANNEL_SENDMSG\",\n  20:\"DBLIB_CHANNEL_CALL\",\n  21:\"DBLIB_RPC_CONNECT\",\n  22:\"DBRPCCALLEE_RPC_CALL\",\n  23:\"DBLIB_RPC_CALL\",\n  24:\"DBNET_CONNECT\",\n  25:\"DBLIB_RPC_INIT\",\n  26:\"DBLIB_RPC_REGISTER\",\n  27:\"DBLIB_CF_CALL\",\n  28:\"DBNET_CHANNEL_CONNECT\",\n  29:\"DBNET_CHANNEL_DISCONNECT\",\n  30:\"DBLIB_CHANNEL_CONNECT\",\n  31:\"DBLIB_CHANNEL_DISCONNECT\",\n  32:\"DBLIB_CF_REGFN\",\n  33:\"DBLIB_RPC_REGFN\"\n};\n  \nconst code_lookup = {\n  1:\"INVALID_URL\",\n  2:\"INVALID_AUTH_PARAM\",\n  3:\"ERR_\",\n  4:\"INVALID_ACCESSTOKEN_FUNCTION\",\n  5:\"HTTP_\",\n  6:\"AUTH_FAILED\",\n  7:\"INVALID_CLIENTFUNCTION\",\n  8:\"NETWORK_DISCONNECTED\",\n  9:\"INVALID_EVENTNAME\",\n  10:\"INVALID_CALLBACK\",\n  11:\"INVALID_CHANNELNAME\",\n  12:\"ACCESSTOKEN_FAILED\",\n  13:\"CALLEE_EXCEPTION\",\n  14:\"INVALID_CHANNELNAME_LENGTH\",\n  15:\"CHANNEL_ALREADY_SUBSCRIBED\",\n  16:\"CHANNEL_NOT_SUBSCRIBED\",\n  17:\"CHANNEL_ALREADY_UNSUBSCRIBED\",\n  18:\"INVALID_SERVERNAME\",\n  19:\"RPC_TIMEOUT\",\n  20:\"INVALID_SUBJECT\",\n  21:\"RECONNECT_ATTEMPT_EXCEEDED\",\n  22:\"DISCONNECT_REQUEST\",\n  23:\"RECONNECT_REQUEST\",\n  24:\"INVALID_FUNCTION\",\n  25:\"RESPONSE_TIMEOUT\",\n  26:\"RPC_INVALID_FUNCTIONS\",\n  27:\"ACCESS_TOKEN_FAIL\",\n  28:\"ACCESS_TOKEN\",\n  29:\"CHANNEL_EXISTS\",\n  30:\"CHANNEL_ALREADY_CONNECTED\",\n  31:\"INVALID_CHANNEL\",\n  32:\"UNSUBSCRIBE_ALREADY_INITIATED\",\n  33:\"INVALID_TYPE\",\n  34:\"DISCONNECT_ALREADY_INITIATED\",\n  35:\"INVALID_BINDING\",\n  36:\"ACCESS_DENIED\",\n  37:\"RESPONSE_OBJECT_CLOSED\",\n  38:\"ID_GENERATION_FAILED\",\n  39:\"INVALID_FUNCTION_NAME\",\n  40:\"INVALID_CHANNEL_TYPE\",\n  41:\"INVALID_CHANNEL_TYPE_BINDING\"\n};\n  \n\n\nexport class dBError extends Error {\n  constructor(ekey, elist = undefined) {\n    let mflag = false;\n    if (ekey in errMsg) {\n      super(ekey);\n      let evalue = errMsg[ekey];\n      if (evalue.length == 2) {\n        if (evalue[0] in source_lookup) {\n          this.source = source_lookup[evalue[0]];\n          mflag = true;\n        } else {\n          this.source = \"DBLIB_EXCEPTION\" + \"_\" + evalue[0];\n          this.code = evalue[0] + \"_undefined\";\n        }\n\n        if (evalue[1] in code_lookup) {\n          this.code = code_lookup[evalue[1]];\n        } else {\n          if (mflag)\n            this.code = evalue[1] + \"_undefined\";\n          else\n            this.code = evalue[0] + \"_\" + evalue[1] + \"_undefined\";\n        }\n      } else {\n        this.source = \"DBLIB_EXCEPTION\";\n      }\n\n      if (elist) {\n        this.message = elist.join(\", \");\n      } else {\n        this.message = \"\";\n      }\n\n    } else {\n      super(ekey);\n      this.source = \"DBLIB_EXCEPTION\";\n      this.code = ekey + \"_undefined\";\n    }\n    if(Error.captureStackTrace){\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this._EKEY = ekey;\n  }\n\n  updatecode(code, message = undefined) {\n    if(code){\n      if(this.code.charAt(this.code.length-1) != \"_\"){\n        this.code = this.code + \"_\" +  code;\n      }else{\n        this.code = this.code + code;\n      }\n    }\n    if (message) this.message = message;\n  }\n\n  getEKEY() {\n    return this._EKEY;\n  }\n}","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nimport { dBError } from \"../exception/errorMessages.js\";\n\nexport class dispatcher { \n\n  constructor() {\n    this._local_register = new Map();\n    this._global_register = [];\n  }\n\n\n  isExists(eventName) {\n    return this._local_register.has(eventName);\n  }\n\n  bind(eventName, callback) {\n    if (!eventName)  throw (new dBError(\"E012\")); \n    if (!callback) throw (new dBError(\"E013\"));\n\n    if (typeof (eventName) != \"string\") throw (new dBError(\"E012\"));\n    if (typeof (callback) != \"function\") throw (new dBError(\"E013\"));\n\n    if (!this._local_register.has(eventName)) {\n      this._local_register.set(eventName, [callback]);\n    } else {\n      this._local_register.get(eventName).push(callback);\n    }\n  }\n\n  bind_all(callback) {\n    if (!callback) throw (new dBError(\"E013\"));\n    if (typeof (callback) != \"function\") throw (new dBError(\"E013\"));\n    this._global_register.push(callback);\n  }\n\n\n  unbind(eventName, callback) {\n    if (!eventName && !callback) {\n      this._local_register = new Map();\n      return;\n    }\n\n    if (eventName && !callback) {\n      this._local_register.delete(eventName);\n      return;\n    }\n\n    if (eventName && callback) {\n      this._local_register.get(eventName).forEach(ca => {\n        if (ca === callback) {\n          delete this._local_register.get(eventName)[ca];\n        }\n      });\n    }\n  }\n\n\n  unbind_all(callback) {\n    if (!callback) {\n      this._global_register = [];\n      return;\n    }\n    delete this._global_register[callback];\n  }\n\n\n  emit2(eventName, channelName, sessionId, action, response) {\n    if (this._local_register.has(eventName)) {\n      var callbacks = this._local_register.get(eventName);\n      if (callbacks.length > 0) {\n        for (let i = 0; i < callbacks.length; i++) {\n          callbacks[i](channelName, sessionId, action, response);\n        }\n      }\n    } \n  }\n\n  emit_cf(functionName, inparameter, response, rsub = null) {\n    if (this._local_register.has(functionName)) {\n      var callbacks = this._local_register.get(functionName);\n      if (callbacks.length > 0) {\n        callbacks[0](inparameter, response, rsub);\n      }\n    } \n  }\n\n  emit_connectionState(eventName, payload = undefined, metadata = undefined) {\n    const global_registry_call = (index) => {\n      if (!payload && !metadata) this._global_register[index]();\n      if (!payload && metadata) this._global_register[index](undefined, metadata);\n      if (payload && metadata) this._global_register[index](payload, metadata);\n      if (payload && !metadata) this._global_register[index](payload);\n      index = index + 1;\n      if (index < this._global_register.length) global_registry_call(index);\n    };\n    if (this._global_register.length > 0) global_registry_call(0);\n    if (this._local_register.has(eventName)) {\n      var callbacks = this._local_register.get(eventName);\n      const local_registry_call = (index) => {\n        if (!payload && !metadata) callbacks[index]();\n        if (!payload && metadata) callbacks[index](undefined, metadata);\n        if (payload && metadata) callbacks[index](payload, metadata);\n        if (payload && !metadata) callbacks[index](payload);\n        index = index + 1;\n        if (index < callbacks.length) local_registry_call(index);\n      };\n      if (callbacks.length > 0) local_registry_call(0);\n    }\n  }\n\n\n  emit_channel(eventName, payload = undefined, metadata = undefined) {\n    const global_registry_call = (index) => {\n      if (!payload && !metadata) this._global_register[index]();\n      if (!payload && metadata) this._global_register[index](undefined, metadata);\n      if (payload && metadata) this._global_register[index](payload, metadata);\n      if (payload && !metadata) this._global_register[index](payload);\n      index = index + 1;\n      if (index < this._global_register.length) global_registry_call(index);\n    };\n    \n    if (this._global_register.length > 0) global_registry_call(0);\n    \n    if (this._local_register.has(eventName)) {\n      var callbacks = this._local_register.get(eventName);\n      const local_registry_call = (index) => {\n        if (!payload && !metadata) callbacks[index]();\n        if (!payload && metadata) callbacks[index](undefined, metadata);\n        if (payload && metadata) callbacks[index](payload, metadata);\n        if (payload && !metadata) callbacks[index](payload);\n        index = index + 1;\n        if (index < callbacks.length) local_registry_call(index);\n      };\n      if (callbacks.length > 0) local_registry_call(0);\n    }\n  }\n\n  emit_clientfunction(functionName, inparameter, response = null, rsub = null) {\n    if (this._local_register.has(functionName)) {\n      var callbacks = this._local_register.get(functionName);\n      if (callbacks.length > 0) {\n        for (let index = 0; index < callbacks.length; index++) {\n          callbacks[index](inparameter, response, rsub);\n        }\n\n      }\n    }\n  }\n\n\n  emit(eventName, EventInfo, channelName, metadata) {\n    const global_registry_call = (index) => {\n      if (EventInfo && channelName && metadata) {\n        this._global_register[index](eventName, channelName, EventInfo, metadata);\n      } else if (EventInfo && channelName && !metadata) {\n        this._global_register[index](eventName, channelName, EventInfo);\n      } else if (EventInfo && !channelName && metadata) {\n        this._global_register[index](eventName, EventInfo, metadata);\n      } else if (EventInfo && !channelName && !metadata) {\n        this._global_register[index](eventName, EventInfo);\n      } else if (!EventInfo && !channelName && !metadata) {\n        this._global_register[index](eventName);\n      } else if (!EventInfo && channelName && !metadata) {\n        this._global_register[index](eventName, channelName);\n      }\n\n      index = index + 1;\n      if (index < this._global_register.length) {\n        global_registry_call(index);\n      }\n    };\n\n    if (this._global_register.length > 0) {\n      global_registry_call(0);\n    }\n\n\n    if (this._local_register.has(eventName)) {\n      var callbacks = this._local_register.get(eventName);\n\n      const local_registry_call = (index) => {\n        if (EventInfo && channelName && metadata) {\n          callbacks[index](channelName, eventName, EventInfo, metadata);\n        } else if (EventInfo && channelName && !metadata) {\n          callbacks[index](channelName, eventName, EventInfo);\n        } else if (EventInfo && !channelName && metadata) {\n          callbacks[index](eventName, EventInfo, metadata);\n        } else if (EventInfo && !channelName && !metadata) {\n          callbacks[index](EventInfo);\n        } else if (!EventInfo && !channelName && !metadata) {\n          callbacks[index]();\n        } else if (!EventInfo && channelName && !metadata) {\n          callbacks[index](channelName);\n        }\n\n        index = index + 1;\n        if (index < callbacks.length) {\n          local_registry_call(index);\n        }\n      };\n\n      if (callbacks.length > 0) {\n        local_registry_call(0);\n      }\n\n    }\n  }\n}","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nexport const states = Object.freeze({\n  CONNECTED: \"connected\",\n  ERROR: \"connect_error\",\n  DISCONNECTED: \"disconnected\",\n  RECONNECTING: \"reconnecting\",\n  CONNECTING: \"connecting\",\n  STATE_CHANGE: \"state_change\",\n  RECONNECT_ERROR: \"reconnect_error\",\n  RECONNECT_FAILED: \"reconnect_failed\",\n  RECONNECTED: \"reconnected\",\n  CONNECTION_BREAK: \"connection_break\",\n  RTTPONG: \"rttpong\",\n  RTTPING: \"rttping\"\n});","/* eslint-disable linebreak-style */\r\n\r\n/*\r\n\tDataBridges JavaScript client Library for browsers\r\n\thttps://www.databridges.io/\r\n\r\n\r\n\r\n\tCopyright 2022 Optomate Technologies Private Limited.\r\n\r\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\r\n\tyou may not use this file except in compliance with the License.\r\n\tYou may obtain a copy of the License at\r\n\r\n\t    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\tUnless required by applicable law or agreed to in writing, software\r\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\r\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\tSee the License for the specific language governing permissions and\r\n\tlimitations under the License.\r\n*/\r\n\r\n\r\nfunction utf8AbFromStr(str) {\r\n  const encoder = new TextEncoder();\r\n  return encoder.encode(str);\r\n}\r\n\r\n\r\nexport function updatedBNewtworkSC(dbcore, dbmsgtype, channelName, sid, channelToken, subject, source_id, t1, seqnum = undefined) {\r\n  if (!subject) subject = null;\r\n  if (!channelToken) channelToken = null;\r\n  if (!source_id) source_id = null;\r\n  if (!t1) t1 = null;\r\n  if (!seqnum) seqnum = null;\r\n\r\n  let msgDbp = {\r\n    \"eventname\": \"db\",\r\n    \"dbmsgtype\": dbmsgtype,\r\n    \"subject\": subject,\r\n    \"rsub\": null,\r\n    \"sid\": sid,\r\n    \"payload\": (channelToken) ? utf8AbFromStr(channelToken) : utf8AbFromStr(\"\"),\r\n    \"fenceid\": channelName,\r\n    \"rspend\": null,\r\n    \"rtrack\": null,\r\n    \"rtrackstat\": null,\r\n    \"t1\": t1,\r\n    \"latency\": null,\r\n    \"globmatch\": 0,\r\n    \"sourceid\": source_id,\r\n    \"sourceip\": null,\r\n    \"replylatency\": null,\r\n    \"oqueumonitorid\": seqnum\r\n  };\r\n  return dbcore.send(msgDbp);\r\n}\r\n\r\n\r\nexport function updatedBNewtworkCF(dbcore, dbmsgtype, sessionid, functionName, returnSubject, sid, payload, rspend, rtrack) {\r\n  if (!functionName) functionName = null;\r\n  if (!returnSubject) returnSubject = null;\r\n  if (!sid) sid = null;\r\n  if (!payload) payload = null;\r\n  if (!rspend) rspend = false;\r\n  if (!rtrack) rtrack = null;\r\n  if (!sessionid) sessionid = null;\r\n\r\n  let msgDbp = {\r\n    \"eventname\": \"db\",\r\n    \"dbmsgtype\": dbmsgtype,\r\n    \"subject\": functionName,\r\n    \"rsub\": returnSubject,\r\n    \"sid\": sid,\r\n    \"payload\": (payload) ? utf8AbFromStr(payload) : utf8AbFromStr(\"\"),\r\n    \"fenceid\": sessionid,\r\n    \"rspend\": rspend,\r\n    \"rtrack\": rtrack,\r\n    \"rtrackstat\": null,\r\n    \"t1\": null,\r\n    \"latency\": null,\r\n    \"globmatch\": 0,\r\n    \"sourceid\": null,\r\n    \"sourceip\": null,\r\n    \"replylatency\": null,\r\n    \"oqueumonitorid\": null\r\n  };\r\n  return dbcore.send(msgDbp);\r\n}\r\n\r\n\r\n\r\nexport function GenerateUniqueId() {\r\n  return (\"\" + Math.random()).substring(2, 8);\r\n} \r\n\r\nexport const systemEvents = Object.freeze({\r\n  SUBSCRIBE_SUCCESS: \"dbridges:subscribe.success\",\r\n  SUBSCRIBE_FAIL: \"dbridges:subscribe.fail\",\r\n  ONLINE: \"dbridges:channel.online\",\r\n  OFFLINE: \"dbridges:channel.offline\", \r\n  REMOVE: \"dbridges:channel.removed\", \r\n  UNSUBSCRIBE_SUCCESS: \"dbridges:unsubscribe.success\",\r\n  UNSUBSCRIBE_FAIL: \"dbridges:unsubscribe.fail\", \r\n  CONNECT_SUCCESS: \"dbridges:connect.success\",\r\n  CONNECT_FAIL: \"dbridges:connect.fail\", \r\n  DISCONNECT_SUCCESS: \"dbridges:disconnect.success\",\r\n  DISCONNECT_FAIL: \"dbridges:disconnect.fail\", \r\n  RESUBSCRIBE_SUCCESS: \"dbridges:resubscribe.success\",\r\n  RESUBSCRIBE_FAIL: \"dbridges:resubscribe.fail\", \r\n  RECONNECT_SUCCESS: \"dbridges:reconnect.success\",\r\n  RECONNECT_FAIL: \"dbridges:reconnect.fail\",\r\n  PARTICIPANT_JOINED: \"dbridges:participant.joined\",\r\n  PARTICIPANT_LFET: \"dbridges:participant.left\", \r\n  REGISTRATION_SUCCESS: \"dbridges:rpc.server.registration.success\",\r\n  REGISTRATION_FAIL: \"dbridges:rpc.server.registration.fail\",\r\n  SERVER_ONLINE: \"dbridges:rpc.server.online\",\r\n  SERVER_OFFLINE: \"dbridges:rpc.server.offline\", \r\n  UNREGISTRATION_SUCCESS: \"dbridges:rpc.server.unregistration.success\",\r\n  UNREGISTRATION_FAIL: \"dbridges:rpc.server.unregistration.fail\", \r\n  RPC_CONNECT_SUCCESS: \"dbridges:rpc.server.connect.success\",\r\n  RPC_CONNECT_FAIL: \"dbridges:rpc.server.connect.fail\" \r\n});\r\n\r\n\r\nexport const accessTokenActions = Object.freeze({\r\n  CHANNELSUBSCRIBE: \"channel.subscribe\",\r\n  CHANNELCONNECT: \"channel.connect\",\r\n  RPCCONNECT: \"rpc.connect\",\r\n  RPCREGISTER: \"rpc.register\",\r\n  SYSTEM_CHANNELSUBSCRIBE: \"system_channel.subscribe\"\r\n});","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nexport const MessageTypes = Object.freeze({\n  SUBSCRIBE_TO_CHANNEL: 11,\n  CONNECT_TO_CHANNEL: 12,\n  UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL: 13,\n  PUBLISH_TO_CHANNEL: 16,\n  SERVER_SUBSCRIBE_TO_CHANNEL: 111,\n  SERVER_UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL: 113,\n  SERVER_PUBLISH_TO_CHANNEL: 116,\n  SERVER_CHANNEL_SENDMSG: 117,\n  LATENCY: 99,\n  SYSTEM_MSG: 0,\n  PARTICIPANT_JOIN: 17,\n  PARTICIPANT_LEFT: 18,\n  CF_CALL_RECEIVED: 44,\n  CF_CALL: 44,\n  CF_CALL_RESPONSE: 46,\n  CF_CALL_TIMEOUT: 49,\n  CF_RESPONSE_TRACKER: 48,\n  CF_CALLEE_QUEUE_EXCEEDED: 50,\n  REGISTER_RPC_SERVER: 51,\n  UNREGISTER_RPC_SERVER: 52,\n  CONNECT_TO_RPC_SERVER: 53,\n  CALL_RPC_FUNCTION: 54,\n  CALL_CHANNEL_RPC_FUNCTION: 55,\n  RPC_CALL_RECEIVED: 54,\n  RPC_CALL_RESPONSE: 56,\n  RPC_CALL_TIMEOUT: 59,\n  RPC_RESPONSE_TRACKER: 58,\n  RPC_CALLEE_QUEUE_EXCEEDED: 60\n});","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\nimport { states } from \"./states.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\n\nexport class ConnectionState {\n  constructor(dBCoreObject) {\n    this._state = \"\";\n    this._isconnected = false;\n    this._NoChangeEvents = undefined;\n    this._supportedEvents = [\"connect_error\", \"connected\", \"disconnected\",\n      \"reconnecting\", \"connecting\", \"state_change\",\n      \"reconnect_error\", \"reconnect_failed\", \"reconnected\",\n      \"connection_break\", \"rttpong\"];\n         \n    this._registry = new dispatcher();\n    this._newLifeCycle = true;\n    this.reconnect_attempt = 0;\n    this._dbcore = dBCoreObject;\n    this._rttms = undefined;\n  }\n\n  get rttms() {\n    return this._rttms;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  set state(value){\n    this._state = value;\n  }\n\n  get isconnected(){\n    return this._isconnected;\n  }\n\n\n  rttping(payload = null) {\n    const now = new Date();\n    const t1 = now.getTime();\n    let m_status = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.SYSTEM_MSG, null, null, payload, \"rttping\", null, t1);\n    if (!m_status) throw (new dBError(\"E011\"));\n  }\n\n  set_newLifeCycle(value) {\n    this._newLifeCycle = value;\n  }\n\n  get_newLifeCycle() {\n    return this._newLifeCycle;\n  }\n\n  bind(eventName, callback) {\n    if (!(eventName)) throw (new dBError(\"E012\"));\n\n    if (!(callback)) throw (new dBError(\"E013\"));\n\n    if (!(typeof eventName === \"string\")) throw (new dBError(\"E012\"));\n\n    if (!(this._supportedEvents.includes(eventName))) throw (new dBError(\"E012\"));\n\n    if (!(typeof callback === \"function\")) throw (new dBError(\"E013\"));\n\n    this._registry.bind(eventName, callback);\n\n  }\n\n  unbind(eventName, callback) {\n    this._registry.unbind(eventName, callback);\n  }\n\n\n  _updatestates(eventName) {\n    switch (eventName) {\n    case states.CONNECTED:\n    case states.RECONNECTED:\n    case states.RTTPONG:\n    case states.RTTPING:\n      this._isconnected = true;\n      break;\n    default:\n      this._isconnected = false;\n      break;\n    }\n  }\n\n  _handledispatcher(eventName, eventInfo) {\n    let previous = this._state;\n    if (![\"reconnect_attempt\", \"rttpong\", \"rttping\"].includes(eventName)) this._state = eventName; this._state = eventName;\n\n    this._updatestates(eventName);\n\n    if (eventName != previous) { \n      if (![\"reconnect_attempt\", \"rttpong\", \"rttping\"].includes(eventName)) {\n        if (![\"reconnect_attempt\", \"rttpong\", \"rttping\"].includes(previous)) {\n          let leventInfo = { \"previous\": previous, \"current\": eventName };\n          this._state = eventName;\n          if(eventName == \"disconnected\"){\n            this._state = \"\";\n          }\n          this._registry.emit_connectionState(states.STATE_CHANGE, leventInfo);\n        }\n      }\n    }\n\n    if (eventInfo) {\n      this._registry.emit_connectionState(eventName, eventInfo);\n    } else {\n      this._registry.emit_connectionState(eventName);\n    }\n\n    if (eventName == \"reconnected\") {\n      this._state = \"connected\";\n    }\n\n  }\n\n}\n","/* eslint-disable no-mixed-spaces-and-tabs */\n\n/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\nexport class channel extends dispatcher { \n  constructor(channelName, sid, dBCoreObject) {\n\t  super();\n\t  this._channelName = channelName;\n\t  this._sid = sid;\n\t  this._dbcore = dBCoreObject;\n\t  this._isOnline = false;\n  }\n\n  getChannelName() {\n\t  return this._channelName;\n  }\n\n  isOnline() {\n\t  return this._isOnline;\n  }\n\n  _set_isOnline(value) {\n\t  this._isOnline = value;\n  } \n\n  publish(eventName, eventData, seqnum = undefined) {\n\t  if (!this._isOnline) throw (new dBError(\"E014\"));\n\n\t  if (this._channelName.toLowerCase() == \"sys:*\") throw (new dBError(\"E015\"));\n\t  if (!eventName) throw (new dBError(\"E058\"));\n\t  if (typeof eventName != \"string\") throw (new dBError(\"E059\"));\n\n\t  let m_status = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.PUBLISH_TO_CHANNEL, this._channelName, null, eventData, eventName, null, null, seqnum);\n\n\t  if (!m_status) throw (new dBError(\"E014\"));\n\n\t  return;\n  }\n\n\n  call(functionName, payload, ttl, callback) {\n\t  return new Promise((resolve, reject) => {\n\t    if (![\"channelMemberList\", \"channelMemberInfo\", \"timeout\", \"err\"].includes(functionName)) {\n\t      reject(new dBError(\"E038\"));\n\t    } else {\n\t      if (this._channelName.toLowerCase().startsWith(\"prs:\") ||\n\t\t\t\t\tthis._channelName.toLowerCase().startsWith(\"sys:\")) {\n\t        let caller = this._dbcore.rpc.ChannelCall(this._channelName);\n\t        caller.call(functionName, payload, ttl, (response) => {\n\t          callback(response);\n\t        })\n\t          .then((response) => {\n\t            resolve(response);\n\t          })\n\t          .catch((error) => {\n\t            reject(error);\n\t          });\n\t      } else {\n\t        reject(new dBError(\"E039\"));\n\t      }\n\t    }\n\t  });\n  } \n}","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\nconst connectSupportedEvents = [utils.systemEvents.CONNECT_SUCCESS,\n  utils.systemEvents.CONNECT_FAIL,\n  utils.systemEvents.RECONNECT_SUCCESS,\n  utils.systemEvents.RECONNECT_FAIL,\n  utils.systemEvents.DISCONNECT_SUCCESS,\n  utils.systemEvents.DISCONNECT_FAIL,\n  utils.systemEvents.ONLINE,\n  utils.systemEvents.OFFLINE,\n  utils.systemEvents.REMOVE,\n  utils.systemEvents.PARTICIPANT_JOINED,\n  utils.systemEvents.PARTICIPANT_LEFT];\n\n\nexport class channelnbd { \n  constructor(channelName, sid, dBCoreObject) {\n    this._channelName = channelName;\n    this._dbcore = dBCoreObject;\n    this._sid = sid;\n    this._dispatch = new dispatcher();\n    this._isOnline = false;\n  }\n\n  getChannelName() {\n    return this._channelName;\n  }\n\n  isOnline() {\n    return this._isOnline;\n  }\n\n  _set_isOnline(value) {\n    this._isOnline = value;\n  }\n\n\n  publish(eventName, eventData, seqnum = undefined) {\n    if (!this._isOnline) throw (new dBError(\"E014\"));\n\n    if (!eventName) throw (new dBError(\"E058\"));\n    if (typeof eventName != \"string\") throw (new dBError(\"E059\"));\n\n\n    if (this._channelName.toLowerCase() == \"sys:*\") throw (new dBError(\"E015\"));\n\n    let m_status = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.PUBLISH_TO_CHANNEL, this._channelName, null, eventData, eventName, null, null, seqnum);\n\n    if (!m_status) throw (new dBError(\"E014\"));\n    return;\n  }\n\n\n  bind(eventName, callback) {\n    if (connectSupportedEvents.includes(eventName)) {\n      this._dispatch.bind(eventName, callback);\n    } else {\n      throw (new dBError(\"E103\"));\n    }\n  }\n\n  unbind(eventName, callback) {\n    if (connectSupportedEvents.includes(eventName)) {\n      if (this._dispatch.isExists(eventName)) this._dispatch.unbind(eventName, callback);\n    }\n  }\n\n  emit_channel(eventName, EventInfo, channelName, metadata) {\n    this._dispatch.emit_channel(eventName, EventInfo, channelName, metadata);\n  }\n\n  call(functionName, payload, ttl, callback) {\n    return new Promise((resolve, reject) => {\n      if (![\"channelMemberList\", \"channelMemberInfo\", \"timeout\", \"err\"].includes(functionName)) {\n        reject(new dBError(\"E038\"));\n      } else {\n        if (this._channelName.toLowerCase().startsWith(\"prs:\") ||\n                    this._channelName.toLowerCase().startsWith(\"sys:\")) {\n          let caller = this._dbcore.rpc.ChannelCall(this._channelName);\n          caller.call(functionName, payload, ttl, (response) => {\n            callback(response);\n          })\n            .then((response) => {\n              resolve(response);\n            })\n            .catch((error) => {\n              reject(error);\n            });\n        } else {\n          reject(new dBError(\"E039\"));\n        }\n      }\n    });\n  }\n}","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nexport const channelStatus = Object.freeze({\n  SUBSCRIPTION_INITIATED: \"subscription_initiated\",\n  SUBSCRIPTION_PENDING: \"subscription_pending\",\n  SUBSCRIPTION_ACCEPTED: \"subscription_accepted\",\n  SUBSCRIPTION_ERROR: \"subscription_error\", \n  CONNECTION_INITIATED: \"connection_initiated\",\n  CONNECTION_PENDING: \"connection_pending\",\n  CONNECTION_ACCEPTED: \"connection_accepted\",\n  CONNECTION_ERROR: \"connection_error\", \n  UNSUBSCRIBE_INITIATED: \"unsubscribe_initiated\",\n  UNSUBSCRIBE_ACCEPTED: \"unsubscribe_accepted\",\n  UNSUBSCRIBE_ERROR: \"unsubscribe_error\", \n  DISCONNECT_INITIATED: \"disconnect_initiated\",\n  DISCONNECT_ACCEPTED: \"disconnect_accepted\",\n  DISCONNECT_ERROR: \"disconnect_error\"\n});","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nexport class CResponse { \n\n  constructor(m_type, channelName, sid, channels) {\n    this._dbchannel = channels;\n    this._mtype = m_type;\n    this._channelName = channelName;\n    this._sid = sid;\n    this._dbchannel = channels;\n  }\n\n  end(data) { \n    this._dbchannel._send_to_dbr(this._mtype, this._channelName, this._sid, data);\n  }\n\n  exception(info) {\n    let vresult = { \"statuscode\": 9, \"error_message\": info, \"accesskey\": null };\n    this._dbchannel._send_to_dbr(this._mtype, this._channelName, this._sid, vresult);\n  }\n\n} ","/* eslint-disable no-unused-vars */\n/* eslint-disable no-useless-catch */\n\n/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport { channel } from \"./channel.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { channelnbd } from \"./channelnbd.js\";\nimport { channelStatus } from \"./channelstatus.js\";\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\nimport { CResponse } from \"./accessResponse.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\nexport class Channels {\n\n  constructor(dBCoreObject) {\n    this._channel_type = [\"pvt\", \"prs\", \"sys\"];\n    this._channelsid_registry = new Map(); //key sid and value is object \n    this._channelname_sid = new Map();\n    this._dbcore = dBCoreObject;\n    this._dispatch = new dispatcher();\n    this._metadata = {\n      \"channelname\": undefined,\n      \"eventname\": undefined,\n      \"sourcesysid\": undefined,\n      \"sqnum\": undefined,\n      \"sessionid\": undefined,\n      \"intime\": undefined,\n    };\n  }\n\n    bind = (eventName, callback) => {\n      this._dispatch.bind(eventName, callback);\n    }\n\n    unbind = (eventName, callback) => {\n      this._dispatch.unbind(eventName, callback);\n    }\n\n    bind_all = (callback) => {\n      this._dispatch.bind_all(callback);\n    }\n\n    unbind_all = (callback) => {\n      this._dispatch.unbind_all(callback);\n    }\n\n    _handledispatcher(eventName, eventInfo = undefined, metadata = undefined) {\n      this._dispatch.emit_channel(eventName, eventInfo, metadata);\n    }\n\n    _handledispatcherEvents(eventName, eventInfo = undefined, channelName = undefined, metadata = undefined) {\n      this._dispatch.emit_channel(eventName, eventInfo, metadata);\n      let sid = this._channelname_sid.get(channelName);\n      let m_object = this._channelsid_registry.get(sid);\n      if (!m_object) return;\n      m_object.ino.emit_channel(eventName, eventInfo, metadata);\n    }\n\n    isPrivateChannel(channelName) {\n      let flag = false;\n      if (channelName.includes(\":\")) {\n        var sdata = channelName.toLowerCase().split(\":\");\n        if (this._channel_type.includes(sdata[0])) {\n          flag = true;\n        } else {\n          flag = false;\n        }\n      }\n      return flag;\n    }\n\n    _ReSubscribeAll() {\n      const _communicateR = async (mtype, channelName, sid, access_token) => {\n        let cStatus = false;\n        if (mtype == 0) {\n          cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.SUBSCRIBE_TO_CHANNEL, channelName, sid, access_token);\n        } else {\n          \n          cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.CONNECT_TO_CHANNEL, channelName, sid, access_token);\n        }\n        if (!cStatus) {\n          if (mtype == 0) {\n            throw (new dBError(\"E024\"));\n          } else {\n            throw (new dBError(\"E090\"));\n          }\n        }\n      };\n\n      const _ReSubscribe = async (sid) => {\n        let m_object = this._channelsid_registry.get(sid);\n        let access_token = undefined;\n        const mprivate = this.isPrivateChannel(m_object.name);\n\n        switch (m_object.status) {\n        case channelStatus.SUBSCRIPTION_ACCEPTED:\n        case channelStatus.SUBSCRIPTION_INITIATED:\n          try {\n            if (!mprivate) {\n\n              _communicateR(0, m_object.name, sid, access_token);\n            } else {\n              const response = new CResponse(0, m_object.name, sid, this);\n              let m_actiontype = undefined;\n\n              if (m_object.name.toLowerCase().startsWith(\"sys:\")) {\n                m_actiontype = utils.accessTokenActions.SYSTEM_CHANNELSUBSCRIBE;\n              } else {\n                m_actiontype = utils.accessTokenActions.CHANNELSUBSCRIBE;\n              }\n\n              this._dbcore._accesstoken_dispatcher(m_object.name, m_actiontype, response);\n            }\n\n          } catch (error) {\n            this._handleSubscribeEvents([utils.systemEvents.OFFLINE], error, m_object);\n            return;\n          }\n          break;\n        case channelStatus.CONNECTION_INITIATED:\n        case channelStatus.CONNECTION_ACCEPTED:\n          try {\n            if (!mprivate) {\n              _communicateR(1, m_object.name, sid, access_token);\n            } else {\n              const response = new CResponse(1, m_object.name, sid, this);\n              this._dbcore._accesstoken_dispatcher(m_object.name, utils.accessTokenActions.CHANNELCONNECT, response);\n            }\n\n\n          } catch (error) {\n            this._handleSubscribeEvents([utils.systemEvents.OFFLINE], error, m_object);\n            return;\n          }\n          break;\n\n        case channelStatus.UNSUBSCRIBE_INITIATED:\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.UNSUBSCRIBE_SUCCESS, utils.systemEvents.REMOVE], \"\", m_object);\n          this._channelname_sid.delete(m_object.name);\n          this._channelsid_registry.delete(sid);\n\n          break;\n\n        case channelStatus.DISCONNECT_INITIATED:\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.DISCONNECT_SUCCESS, utils.systemEvents.REMOVE], \"\", m_object);\n          this._channelname_sid.delete(m_object.name);\n          this._channelsid_registry.delete(sid);\n          break;\n        }\n\n      };\n\n      this._channelname_sid.forEach((value, key) => {\n        _ReSubscribe(value);\n      });\n    }\n\n    isEmptyOrSpaces(str) {\n      return str === null || (/^ *$/).test(str);\n    }\n\n    _validateChanelName(channelName, error_type = 0) {\n\n      if (!this._dbcore.connectionstate.isconnected) {\n        switch (error_type) {\n        case 0:\n          throw (new dBError(\"E024\"));\n          //break;\n        case 1:\n          throw (new dBError(\"E090\"));\n          //break;\n        default:\n          break;\n        }\n\n      }\n      if (typeof channelName != \"string\") {\n        switch (error_type) {\n        case 0:\n          throw (new dBError(\"E026\"));\n          //break;\n        case 1:\n          throw (new dBError(\"E095\"));\n          //break;\n        \n        default:\n          break;\n        }\n      }\n      if (this.isEmptyOrSpaces(channelName)) {\n        switch (error_type) {\n        case 0:\n          throw (new dBError(\"E025\"));\n          //break;\n        case 1:\n          throw (new dBError(\"E095\"));\n          //break;\n       \n        default:\n          break;\n        }\n      }\n      if (channelName.length > 64) {\n        switch (error_type) {\n        case 0:\n          throw (new dBError(\"E027\"));\n          //break;\n        case 1:\n          throw (new dBError(\"E095\"));\n          //break;\n       \n        default:\n          break;\n        }\n\n      }\n      if (!(/^[a-zA-Z0-9.:_-]*$/.test(channelName))) {\n        switch (error_type) {\n        case 0:\n          throw (new dBError(\"E028\"));\n          //break;\n        case 1:\n          throw (new dBError(\"E095\"));\n          //break;\n        \n        default:\n          break;\n        }\n      }\n\n      if (channelName.includes(\":\")) {\n        var sdata = channelName.toLowerCase().split(\":\");\n        if (!this._channel_type.includes(sdata[0])) {\n          switch (error_type) {\n          case 0:\n            throw (new dBError(\"E028\"));\n            //break;\n          case 1:\n            throw (new dBError(\"E095\"));\n            //break;\n          default:\n                    //break;\n          }\n        }\n      }\n\n    }\n\n\n    _communicate(mtype, channelName, mprivate, action) {\n      let cStatus = false;\n      let m_channel = undefined;\n      let m_value = undefined;\n      let access_token = null;\n      let sid = utils.GenerateUniqueId();\n\n      if (!mprivate) {\n        if (mtype == 0) {\n          cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.SUBSCRIBE_TO_CHANNEL, channelName, sid, access_token);\n        } else {\n          cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.CONNECT_TO_CHANNEL, channelName, sid, access_token);\n        }\n        if (!cStatus) {\n\n          if (mtype == 0) {\n            throw (new dBError(\"E024\"));\n          } else {\n            throw (new dBError(\"E090\"));\n          }\n        } //throw(new Error(\"library is not connected with the dbridges network\")); \n      } else {\n\n        const response = new CResponse(mtype, channelName, sid, this);\n        this._dbcore._accesstoken_dispatcher(channelName, action, response);\n      }\n\n      if (mtype == 0) {\n        m_channel = new channel(channelName, sid, this._dbcore);\n        m_value = { \"name\": channelName, \"type\": \"s\", \"status\": channelStatus.SUBSCRIPTION_INITIATED, \"ino\": m_channel };\n      } else {\n        m_channel = new channelnbd(channelName, sid, this._dbcore);\n        m_value = { \"name\": channelName, \"type\": \"c\", \"status\": channelStatus.CONNECTION_INITIATED, \"ino\": m_channel };\n      }\n\n      this._channelsid_registry.set(sid, m_value);\n      this._channelname_sid.set(channelName, sid);\n      \n      return m_channel;\n    }\n\n    _verify_acccess_response(access_object) {\n      let merror = \"\";\n\n      if (!(\"statuscode\" in access_object)) {\n        merror = \"the return object structure is blank, does not contain statuscode key\";\n        return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n      }\n\n      if ((typeof access_object.statuscode != \"number\")) {\n        merror = \"the return object structure is blank, statuscode vaule must be numeric\";\n        return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n      }\n\n      if (access_object.statuscode != 0) {\n        if (!(\"error_message\" in access_object)) {\n          merror = \"access_token function return statuscode: \" + access_object.statuscode + \" error_message tag missing\";\n        } else {\n          merror = access_object.error_message;\n        }\n        return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n      }\n\n      if (!(\"accesskey\" in access_object)) {\n        merror = \"access_token function return statuscode: \" + access_object.statuscode + \" accesskey tag missing\";\n        return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n      }\n      if (!access_object.accesskey) {\n        merror = \"access_token function return statuscode: \" + access_object.statuscode + \" accesskey is blank\";\n        return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n      }\n      return { \"result\": true, \"msg\": \"\", \"token\": access_object.accesskey };\n    }\n\n    _failure_dispatcher(mtype, sid, reason) {\n\n      const m_object = this._channelsid_registry.get(sid);\n      m_object.ino._set_isOnline(false);\n      let dberror = undefined;\n      if (mtype == 0) {\n        dberror = new dBError(\"E091\");\n        dberror.updatecode(\"\", reason);\n        this._handleSubscribeEvents([utils.systemEvents.SUBSCRIBE_FAIL], dberror, m_object);\n\n      } else {\n        dberror = new dBError(\"E092\");\n        dberror.updatecode(\"\", reason);\n        this._handleSubscribeEvents([utils.systemEvents.CONNECT_FAIL], dberror, m_object);\n\n      }\n      this._channelname_sid.delete(m_object.name);\n      this._channelsid_registry.delete(sid);\n    }\n\n    _send_to_dbr(mtype, channelName, sid, access_data) {\n      let cStatus = undefined;\n\n      let v_result = this._verify_acccess_response(access_data);\n      if (!v_result.result) {\n        this._failure_dispatcher(mtype, sid, v_result.msg);\n        return;\n      }\n      let access_token = v_result.token;\n\n      if (mtype == 0) {\n        cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.SUBSCRIBE_TO_CHANNEL, channelName, sid, access_token);\n      } else {\n        cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.CONNECT_TO_CHANNEL, channelName, sid, access_token);\n      }\n\n      if (!cStatus) {\n        this._failure_dispatcher(mtype, sid, \"library is not connected with the dbridges network\");\n      }\n    }\n\n    subscribe(channelName) {\n      if (channelName.toLowerCase() != \"sys:*\") {\n        try {\n          this._validateChanelName(channelName);\n        } catch (error) {\n          throw (error);\n        }\n      }\n\n      if (this._channelname_sid.has(channelName)) throw (new dBError(\"E093\"));\n\n      const mprivate = this.isPrivateChannel(channelName);\n\n      let m_channel = undefined;\n      let m_actiontype = undefined;\n\n      if (channelName.toLowerCase().startsWith(\"sys:\")) {\n        m_actiontype = utils.accessTokenActions.SYSTEM_CHANNELSUBSCRIBE;\n      } else {\n        m_actiontype = utils.accessTokenActions.CHANNELSUBSCRIBE;\n      }\n\n\n      try {\n\n        m_channel = this._communicate(0, channelName, mprivate, m_actiontype);\n      } catch (error) {\n        throw (error);\n      }\n      return m_channel;\n    }\n\n\n    connect(channelName) {\n      if (channelName.toLowerCase() != \"sys:*\") {\n        try {\n          this._validateChanelName(channelName, 1);\n        } catch (error) {\n          throw (error);\n        }\n      }\n\n      if (channelName.toLowerCase().startsWith(\"sys:\")) throw (new dBError(\"E095\"));\n\n      if (this._channelname_sid.has(channelName)) throw (new dBError(\"E094\"));\n\n      const mprivate = this.isPrivateChannel(channelName);\n\n      let m_channel = undefined;\n      try {\n        m_channel = this._communicate(1, channelName, mprivate, utils.accessTokenActions.CHANNELCONNECT);\n      } catch (error) {\n        throw (error);\n      }\n      return m_channel;\n    }\n\n\n\n    unsubscribe(channelName) {\n      if (!this._channelname_sid.has(channelName)) throw (new dBError(\"E030\"));\n\n      let sid = this._channelname_sid.get(channelName);\n      let m_object = this._channelsid_registry.get(sid);\n      let m_status = false;\n      if (m_object.type != \"s\") throw (new dBError(\"E096\"));\n\n      if (m_object.status == channelStatus.UNSUBSCRIBE_INITIATED) throw (new dBError(\"E097\"));\n\n      if (m_object.status == channelStatus.SUBSCRIPTION_ACCEPTED ||\n            m_object.status == channelStatus.SUBSCRIPTION_INITIATED ||\n            m_object.status == channelStatus.SUBSCRIPTION_PENDING ||\n            m_object.status == channelStatus.SUBSCRIPTION_ERROR ||\n            m_object.status == channelStatus.UNSUBSCRIBE_ERROR) {\n        m_status = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL, channelName, sid, undefined);\n      }\n\n      if (!m_status) throw (new dBError(\"E098\"));\n\n      this._channelsid_registry.get(sid).status = channelStatus.UNSUBSCRIBE_INITIATED;\n    }\n\n\n    disconnect(channelName) {\n      if (!this._channelname_sid.has(channelName)) throw (new dBError(\"E099\"));\n\n      let sid = this._channelname_sid.get(channelName);\n      let m_object = this._channelsid_registry.get(sid);\n      let m_status = false;\n\n      if (m_object.type != \"c\") throw (new dBError(\"E100\"));\n\n      if (m_object.status == channelStatus.DISCONNECT_INITIATED) throw (new dBError(\"E101\"));\n\n      if (m_object.status == channelStatus.CONNECTION_ACCEPTED ||\n            m_object.status == channelStatus.CONNECTION_INITIATED ||\n            m_object.status == channelStatus.CONNECTION_PENDING ||\n            m_object.status == channelStatus.CONNECTION_ERROR ||\n            m_object.status == channelStatus.DISCONNECT_ERROR) {\n        m_status = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL, channelName, sid, undefined);\n      }\n\n      if (!m_status) throw (new dBError(\"E102\"));\n\n      this._channelsid_registry.get(sid).status = channelStatus.DISCONNECT_INITIATED;\n    }\n\n    _handleSubscribeEvents(eventName, eventData, m_object) {\n      const dispatchEvents = async (i) => {\n\n        let metadata = Object.assign({}, this._metadata);\n        metadata.channelname = m_object.name;\n        metadata.eventname = eventName[i];\n\n        this._dispatch.emit_channel(eventName[i], eventData, metadata);\n        m_object.ino.emit_channel(eventName[i], eventData, metadata);\n\n        \n        i = i + 1;\n        if (i < eventName.length) {\n          dispatchEvents(i);\n        }\n      };\n      if (eventName.length > 0) {\n        dispatchEvents(0);\n      }\n    }\n\n\n    _updateSubscribeStatus(sid, status, reason) {\n      if (!this._channelsid_registry.has(sid)) return;\n      let m_object = this._channelsid_registry.get(sid);\n\n      switch (m_object.type) {\n      case \"s\":\n        switch (status) {\n        case channelStatus.SUBSCRIPTION_ACCEPTED:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(true);\n          this._handleSubscribeEvents([utils.systemEvents.SUBSCRIBE_SUCCESS, utils.systemEvents.ONLINE], \"\", m_object);\n          break;\n        default:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.SUBSCRIBE_FAIL], reason, m_object);\n          this._channelname_sid.delete(m_object.name);\n          this._channelsid_registry.delete(sid);\n          break;\n        }\n        break;\n      case \"c\":\n        switch (status) {\n        case channelStatus.CONNECTION_ACCEPTED:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(true);\n          this._handleSubscribeEvents([utils.systemEvents.CONNECT_SUCCESS, utils.systemEvents.ONLINE], \"\", m_object);\n          break;\n        default:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.CONNECT_FAIL], reason, m_object);\n          this._channelname_sid.delete(m_object.name);\n          this._channelsid_registry.delete(sid);\n\n          break;\n\n        }\n        break;\n      default:\n        break;\n      }\n    }\n\n\n    _updateSubscribeStatusRepeat(sid, status, reason) {\n      if (!this._channelsid_registry.has(sid)) return;\n      let m_object = this._channelsid_registry.get(sid);\n\n      switch (m_object.type) {\n      case \"s\":\n        switch (status) {\n        case channelStatus.SUBSCRIPTION_ACCEPTED:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(true);\n          this._handleSubscribeEvents([utils.systemEvents.RESUBSCRIBE_SUCCESS, utils.systemEvents.ONLINE], \"\", m_object);\n          break;\n        default:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.OFFLINE], reason, m_object);\n          break;\n\n        }\n        break;\n      case \"c\":\n        switch (status) {\n        case channelStatus.CONNECTION_ACCEPTED:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(true);\n          this._handleSubscribeEvents([utils.systemEvents.RECONNECT_SUCCESS, utils.systemEvents.ONLINE], \"\", m_object);\n          break;\n        default:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.OFFLINE], reason, m_object);\n          break;\n\n        }\n        break;\n      default:\n        break;\n      }\n    }\n\n    _updateChannelsStatusAddChange(life_cycle, sid, status, reason) {\n      if (life_cycle == 0)  // first time subscription \n      {\n        this._updateSubscribeStatus(sid, status, reason);\n      } else { // resubscribe due to network failure \n        this._updateSubscribeStatusRepeat(sid, status, reason);\n      }\n    }\n\n\n    _updateChannelsStatusRemove(sid, status, reason) {\n      if (!this._channelsid_registry.has(sid)) return;\n      let m_object = this._channelsid_registry.get(sid);\n\n      switch (m_object.type) {\n      case \"s\":\n        switch (status) {\n        case channelStatus.UNSUBSCRIBE_ACCEPTED:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.UNSUBSCRIBE_SUCCESS, utils.systemEvents.REMOVE], \"\", m_object);\n          this._channelname_sid.delete(m_object.name);\n          this._channelsid_registry.delete(sid);\n          break;\n        default:\n          this._channelsid_registry.get(sid).status = channelStatus.SUBSCRIPTION_ACCEPTED;\n          m_object.ino._set_isOnline(true);\n          this._handleSubscribeEvents([utils.systemEvents.UNSUBSCRIBE_FAIL, utils.systemEvents.ONLINE], reason, m_object);\n          break;\n        }\n        break;\n      case \"c\":\n        switch (status) {\n        case channelStatus.DISCONNECT_ACCEPTED:\n          this._channelsid_registry.get(sid).status = status;\n          m_object.ino._set_isOnline(false);\n          this._handleSubscribeEvents([utils.systemEvents.DISCONNECT_SUCCESS, utils.systemEvents.REMOVE], \"\", m_object);\n          this._channelname_sid.delete(m_object.name);\n          this._channelsid_registry.delete(sid);\n          break;\n        default:\n          this._channelsid_registry.get(sid).status = channelStatus.CONNECTION_ACCEPTED;\n          m_object.ino._set_isOnline(true);\n          this._handleSubscribeEvents([utils.systemEvents.DISCONNECT_FAIL, utils.systemEvents.ONLINE], reason, m_object);\n          break;\n        }\n        break;\n      default:\n        break;\n      }\n    }\n\n\n\n    _isonline(sid) {\n      if (!this._channelsid_registry.has(sid)) return false;\n      let m_object = this._channelsid_registry.get(sid);\n      if (m_object.status == channelStatus.CONNECTION_ACCEPTED ||\n            m_object.status == channelStatus.SUBSCRIPTION_ACCEPTED) return true;\n\n      return false;\n    }\n\n    isOnline(channelName) {\n      if (!this._channelname_sid.has(channelName)) throw (new dBError(\"channel name does not exists\"));\n      if (!this._dbcore._isSocketConnected()) return false;\n\n      let sid = this._channelname_sid.get(channelName);\n      return this._isonline(sid);\n    }\n\n    list() {\n      let m_data = [];\n\n      this._channelsid_registry.forEach((value, key) => {\n        let i_data = { \"name\": value.name, \"type\": (value.type == \"s\") ? \"subscribed\" : \"connect\", \"isonline\": this._isonline(key) };\n        m_data.push(i_data);\n      });\n\n      return m_data;\n    }\n\n    _send_OfflineEvents() {\n      this._channelsid_registry.forEach((value, key) => {\n        \n        let metadata = Object.assign({}, this._metadata);\n        metadata.channelname = value.ino.getChannelName();\n        metadata.eventname = utils.systemEvents.OFFLINE;\n        value.ino._set_isOnline(false);\n\n        this._handledispatcherEvents(utils.systemEvents.OFFLINE, value.name, value.name, metadata);\n      });\n    }\n\n    _get_subscribeStatus(sid) {\n      return this._channelsid_registry.get(sid).status;\n    }\n\n\n    _get_channelType(sid) {\n      return this._channelsid_registry.has(sid) ? this._channelsid_registry.get(sid).type : \"\";\n    }\n\n\n    _get_channelName(sid) {\n      return (this._channelsid_registry.has(sid)) ? this._channelsid_registry.get(sid).name : undefined;\n    }\n\n\n    getConnectStatus(sid) {\n      return this._channelsid_registry.get(sid).status;\n    }\n\n\n    getChannel(sid) {\n      if (!this._channelsid_registry.has(sid)) return undefined;\n      return this._channelsid_registry.get(sid).ino;\n    }\n\n    getChannelName(sid) {\n      if (!this._channelsid_registry.has(sid)) return undefined;\n      return this._channelsid_registry.get(sid).name;\n    }\n\n    isSubscribedChannel(sid) {\n      if (!this._channelsid_registry.has(sid)) return false;\n      if (this._channelsid_registry.get(sid).type == \"s\") {\n        return this._channelsid_registry.get(sid).ino.isSubscribed;\n      } else {\n        return false;\n      }\n    }\n\n    cleanUp_All() {\n\n      const clean_channel = (sid) => {\n        return new Promise(resolve => {\n          let mobject = this._channelsid_registry.get(sid);\n          if (mobject.type == \"s\") {\n            mobject.ino.unbind();\n            mobject.ino.unbind_all();\n          } else {\n            mobject.ino.unbind();\n          }\n          resolve();\n        });\n      };\n\n      this._channelname_sid.forEach((value, key) => {\n        let metadata = Object.assign({}, this._metadata);\n        metadata.channelname = key;\n        metadata.eventname = \"dbridges:channel.removed\";\n        this._handledispatcherEvents(utils.systemEvents.REMOVE, undefined, key, metadata);\n        clean_channel(value)\n          .then(() => {\n            this._channelname_sid.delete(key);\n            this._channelsid_registry.delete(value);\n          });\n      });\n\n      //this._dispatch.unbind();\n      //this._dispatch.unbind_all();\n    }\n}\n","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\nexport class CrpcResponse { \n\n\n  constructor(functionName, returnSubect, sid, dbcoreobject) {\n    this._functionName = functionName;\n    this._returnSubsect = returnSubect;\n    this._sid = sid;\n    this._dbcore = dbcoreobject;\n    this._isend = false;\n    this._id = returnSubect;\n    this.tracker = false;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  next(data) {\n    if (!this._isend) {\n      let cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.CF_CALL_RESPONSE, null, this._returnSubsect, null, this._sid, data, this._isend, this.tracker);\n      if (!cstatus) throw (new dBError(\"E068\"));\n    } else {\n      throw (new dBError(\"E105\"));\n    }\n  }\n  end(data) {\n    if (!this._isend) {\n      this._isend = true;\n      let cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.CF_CALL_RESPONSE, null, this._returnSubsect, null, this._sid, data, this._isend, this.tracker);\n      if (!cstatus) throw (new dBError(\"E068\"));\n\n    } else {\n      throw (new dBError(\"E105\"));\n    }\n  }\n\n  exception(expCode, expShortMessage) {\n    let epayload = JSON.stringify({ \"c\": expCode, \"m\": expShortMessage });\n\n    if (!this._isend) {\n      this._isend = true;\n      let cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.CF_CALL_RESPONSE, null, this._returnSubsect, \"EXP\", this._sid, epayload, this._isend, this.tracker);\n      if (!cstatus) throw (new dBError(\"E068\"));\n\n    } else {\n      throw (new dBError(\"E105\"));\n    }\n  }\n}","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\nimport { CrpcResponse } from \"./rpcResponse.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\n\nexport class Crpcclient { \n\n  constructor(dBCoreObject) {\n    this._dispatch = new dispatcher();\n    this._dbcore = dBCoreObject;\n    this.enable = false;\n    this.functions = undefined;\n    this._functionNames = [\"cf.response.tracker\", \"cf.callee.queue.exceeded\"];\n  } \n\n  _verify_function() {\n    let mflag = false;\n    if (this.enable) {\n      if (!this.functions) throw (new dBError(\"E009\"));\n      if (typeof this.functions != \"function\") throw (new dBError(\"E010\"));\n      mflag = true;\n    } else {\n      mflag = true;\n    }\n    return mflag;\n  } \n\n  regfn(functionName, callback) {\n    if (!(functionName)) throw (new dBError(\"E110\")); \n    if (!(callback)) throw (new dBError(\"E111\")); \n    if (!(typeof functionName === \"string\")) throw (new dBError(\"E110\"));\n    if (!(typeof callback === \"function\")) throw (new dBError(\"E111\"));\n\n    if(this._functionNames.includes(functionName)) throw (new dBError(\"E110\"));\n    this._dispatch.bind(functionName, callback);\n  }\n\n\n  unregfn(functionName, callback) {\n    if(this._functionNames.includes(functionName)) return;\n    this._dispatch.unbind(functionName, callback);\n  }\n\n\n\n  bind(eventName, callback) {\n    if (!(eventName)) throw (new dBError(\"E066\")); \n    if (!(callback)) throw (new dBError(\"E067\")); \n    if (!(typeof eventName === \"string\")) throw (new dBError(\"E066\"));\n    if (!(typeof callback === \"function\")) throw (new dBError(\"E067\"));\n\n    if(!this._functionNames.includes(eventName)) throw (new dBError(\"E066\"));\n    \n    this._dispatch.bind(eventName, callback);\n  }\n\n\n  unbind(eventName, callback) {\n    if(!this._functionNames.includes(eventName)) return;\n    this._dispatch.unbind(eventName, callback);\n\n  }\n\n\n  _handle_dispatcher(functionName, returnSubect, sid, payload) {\n    let response = new CrpcResponse(functionName, returnSubect, sid, this._dbcore);\n    this._dispatch.emit_clientfunction(functionName, payload, response);\n  }\n\n  _handle_tracker_dispatcher(responseid, errorcode) {\n\n    this._dispatch.emit_clientfunction(\"cf.response.tracker\", responseid, errorcode);\n  }\n\n  _handle_exceed_dispatcher() {\n    let err = new dBError(\"E070\");\n    err.updatecode(\"CALLEE_QUEUE_EXCEEDED\");\n    this._dispatch.emit_clientfunction(\"cf.callee.queue.exceeded\", err, null);\n  }\n\n  resetqueue() {\n    let m_status  = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.CF_CALLEE_QUEUE_EXCEEDED, null, null, null, null, null, null, null);\n    if (!m_status) throw (new dBError(\"E068\"));\n  }\n\n}\n","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nexport const rpcStatus = Object.freeze({\n  REGISTRATION_INITIATED: \"registration_initiated\",\n  REGISTRATION_PENDING: \"registration_pending\",\n  REGISTRATION_ACCEPTED: \"registration_accepted\",\n  REGISTRATION_ERROR: \"registration_error\",\n\n  RPC_CONNECTION_INITIATED: \"rpc_connection_initiated\",\n  RPC_CONNECTION_PENDING: \"rpc_connection_pending\",\n  RPC_CONNECTION_ACCEPTED: \"rpc_connection_accepted\",\n  RPC_CONNECTION_ERROR: \"rpc_connection_error\",\n\n  UNREGISTRATION_INITIATED: \"unregister_initiated\",\n  UNREGISTRATION_ACCEPTED: \"unregister_accepted\",\n  UNREGISTRATION_ERROR: \"unregister_error\",\n\n  RPC_DISCONNECT_INITIATED: \"rpc_disconnect_initiated\",\n  RPC_DISCONNECT_ACCEPTED: \"rpc_disconnect_accepted\",\n  RPC_DISCONNECT_ERROR: \"rpc_disconnect_error\"\n});","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\nexport class CrpcSResponse { \n\n  constructor(functionName, returnSubect, sid, dbcoreobject) {\n    this._functionName = functionName;\n    this._returnSubsect = returnSubect;\n    this._sid = sid;\n    this._dbcore = dbcoreobject;\n    this._isend = false;\n    this._id = returnSubect;\n    this.tracker = false;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  next(data) {\n    if (!this._isend) {\n      let cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.RPC_CALL_RESPONSE, null, this._returnSubsect, null, this._sid, data, this._isend, this.tracker);\n      if (!cstatus) throw (new dBError(\"E079\"));\n    } else {\n      throw (new dBError(\"E106\"));\n    }\n\n  }\n  end(data) {\n    if (!this._isend) {\n      this._isend = true;\n      let cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.RPC_CALL_RESPONSE, null, this._returnSubsect, null, this._sid, data, this._isend, this.tracker);\n      if (!cstatus) throw (new dBError(\"E079\"));\n    } else {\n      throw (new dBError(\"E106\"));\n    }\n  }\n\n  exception(expCode, expShortMessage) {\n    let epayload = JSON.stringify({ \"c\": expCode, \"m\": expShortMessage });\n\n    if (!this._isend) {\n      this._isend = true; \n      let cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.RPC_CALL_RESPONSE, null, this._returnSubsect, \"EXP\", this._sid, epayload, this._isend, this.tracker); \n      if (!cstatus) throw (new dBError(\"E079\"));\n    } else {\n      throw (new dBError(\"E106\"));\n    }\n  } \n}","/* eslint-disable no-async-promise-executor */\n/* eslint-disable no-unused-vars */\n/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\nimport { CrpcResponse } from \"./rpcResponse.js\";\nimport * as utils from \"../Utils/util.js\";\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport { CrpcSResponse } from \"./rpcSResponse.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\n\nexport class CrpCaller { \n  constructor(serverName, dBCoreObject, rpccoreobject, callertype = \"rpc\") {\n    this._dispatch = new dispatcher();\n    this._dbcore = dBCoreObject;\n    this._rpccore = rpccoreobject;\n\n    this.enable = false;\n    this.functions = undefined;\n    this._sid_functionname = new Map();\n    this._serverName = serverName;\n    this._isOnline = false;\n    this._callerTYPE = callertype;\n  }\n\n\n  getServerName() {\n    return this._serverName;\n  }\n\n  isOnline() {\n    return this._isOnline;\n  }\n\n  _set_isOnline(value) {\n    this._isOnline = value;\n  }\n\n\n  bind(eventName, callback) {\n    if (!(eventName)) throw (new dBError(\"E076\"));\n    if (!(callback)) throw (new dBError(\"E077\"));\n    if (!(typeof eventName === \"string\")) throw (new dBError(\"E076\"));\n    if (!(typeof callback === \"function\")) throw (new dBError(\"E077\"));\n    this._dispatch.bind(eventName, callback);\n  }\n\n  unbind(eventName, callback) {\n    this._dispatch.unbind(eventName, callback);\n  }\n\n\n  _handle_dispatcher(functionName, returnSubect, sid, payload) {\n    let response = new CrpcSResponse(functionName, returnSubect, sid, this._dbcore);\n    this._dispatch.emit_clientfunction(functionName, payload, response);\n  }\n\n\n  _handle_callResponse(sid, payload, isend, rsub) {\n    if (this._sid_functionname.has(sid)) {\n      let mataData = { \"functionName\": this._sid_functionname.get(sid) };\n      this._dispatch.emit_clientfunction(sid, payload, isend, rsub);\n    } else {\n    // This condition should not occur.. If this condition is found then there is a deadlock situation where dbr is sending the data before time is received by the dbr.\n    }\n  }\n\n  _handle_tracker_dispatcher(responseid, errorcode) {\n    this._dispatch.emit_clientfunction(\"rpc.response.tracker\", responseid, errorcode);\n  }\n\n  _handle_exceed_dispatcher() {\n    let err = new dBError(\"E054\");\n    err.updatecode(\"CALLEE_QUEUE_EXCEEDED\");\n    this._dispatch.emit_clientfunction(\"rpc.callee.queue.exceeded\", err, null);\n  }\n\n\n\n  async _call_internal(sessionid, functionName, inparameter, sid, progress_callback) {\n    return new Promise(async (resolve, reject) => {\n      let cstatus = undefined;\n      if (this._callerTYPE == \"rpc\") {\n        cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.CALL_RPC_FUNCTION, sessionid, functionName, null, sid, inparameter);\n      } else {\n        cstatus = utils.updatedBNewtworkCF(this._dbcore, MessageTypes.CALL_CHANNEL_RPC_FUNCTION, sessionid, functionName, null, sid, inparameter);\n      }\n      if (!cstatus) {\n        if (this._callerTYPE == \"rpc\") {\n          reject(new dBError(\"E079\"));\n        } else {\n          reject(new dBError(\"E033\"));\n        }\n      }\n\n      this.bind(sid, (response, rspend, rsub) => {\n        let dberror = undefined;\n        let eobject = undefined;\n        if (!rspend) {\n          if (progress_callback) progress_callback(response);\n        } else {\n          if (rsub != null) {\n            switch (rsub.toUpperCase()) {\n            case \"EXP\": //exception from callee \n              eobject = JSON.parse(response);\n              if (this._callerTYPE == \"rpc\") {\n                dberror = new dBError(\"E055\");\n                dberror.updatecode(eobject.c, eobject.m);\n                reject(dberror);\n              } else { //Channel call\n                dberror = new dBError(\"E041\");\n                dberror.updatecode(eobject.c, eobject.m);\n                reject(dberror);\n              }\n              break;\n            default: // DBNET ERROR \n              if (this._callerTYPE == \"rpc\") {\n                dberror = new dBError(\"E054\");\n                dberror.updatecode(rsub.toUpperCase(), \"\");\n                reject(dberror);\n              } else { //Channel call\n                dberror = new dBError(\"E040\");\n                dberror.updatecode(rsub.toUpperCase(), \"\");\n                reject(dberror);\n              }\n              break;\n            }\n\n          } else {\n            resolve(response);\n          }\n          this.unbind(sid);\n          this._sid_functionname.delete(sid);\n        }\n      });\n    });\n  }\n\n  _GetUniqueSid(sid) {\n    let nsid = sid + utils.GenerateUniqueId();\n    if (this._sid_functionname.has(nsid)) {\n      nsid = (\"\" + Math.random()).substring(2, 8);\n    }\n    return nsid;\n  }\n  \n  call(functionName, inparameter, ttlms, progress_callback) {\n    let sid = \"\";\n    var sid_created = true;\n    var loop_index = 0;\n    var loop_counter = 3;\n    var mflag = false;\n    sid = utils.GenerateUniqueId();\n\n\n    do {\n\n      if (this._sid_functionname.has(sid)) {\n        sid = this._GetUniqueSid(sid);\n        loop_index++;\n      } else {\n        this._sid_functionname.set(sid, functionName);\n        mflag = true;\n      }\n    } while ((loop_index < loop_counter) && (!mflag));\n\n    if (!mflag) {\n      sid = this._GetUniqueSid(sid);\n      if (!this._sid_functionname.has(sid)) {\n        this._sid_functionname.set(sid, functionName);\n      } else {\n        sid_created = false;\n      }\n    }\n\n    if (!sid_created) {\n      if (this._callerTYPE == \"rpc\") {\n        throw (new dBError(\"E108\"));\n      } else {\n        throw (new dBError(\"E109\")); \n      }\n    }\n\n    this._rpccore.store_object(sid, this);\n\n    let timer = undefined;\n\n    return Promise.race([\n      this._call_internal(this._serverName, functionName, inparameter, sid, progress_callback),\n      new Promise((_r, rej) => {\n        timer = setTimeout(() => {\n          this.unbind(sid);\n          this._sid_functionname.delete(sid);\n          //rej({'source': 'dbridges.library' ,'code': 'RPC_TIMEOUT' ,  'message':''});\n          if (this._callerTYPE == \"rpc\") {\n            rej(new dBError(\"E080\"));\n          }else{\n            rej(new dBError(\"E042\"));\n          }\n          utils.updatedBNewtworkCF(this._dbcore, MessageTypes.RPC_CALL_TIMEOUT, null, sid, null, null, null, null, null);\n          clearTimeout(timer);\n        }, ttlms);\n      })\n    ]).then((result) => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      this._rpccore.delete_object(sid);\n      return result;\n    }).catch((err) => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      throw err;\n    });\n  }\n \n \n  emit(eventName, eventData, metadata) {\n    //this._dispatch.emit(eventName, EventInfo, channelName);\n\n    this._dispatch.emit_channel(eventName, eventData, metadata);\n\n  }\n\n\n}","/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nexport class CaccessRpcResponse { \n\n  constructor(serverName, sid, rpc) {\n    this._dbrpc = rpc;\n    this._serverName = serverName;\n    this._sid = sid;\n    this._dbrpc = rpc;\n  }\n\n  end(data) {\n    this._dbrpc._send_to_dbr(this._serverName, this._sid, data);\n  }\n\n  exception(info) {\n    let vresult = { \"statuscode\": 9, \"error_message\": info, \"accesskey\": null };\n    this._dbrpc._send_to_dbr(this._serverName, this._sid, vresult);\n  } \n} ","/* eslint-disable no-useless-catch */\n/* eslint-disable no-unused-vars */\n/*\n\tDataBridges JavaScript client Library for browsers\n\thttps://www.databridges.io/\n\n\n\n\tCopyright 2022 Optomate Technologies Private Limited.\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\nimport { MessageTypes } from \"../msgTypes/dBMessageTypes.js\";\nimport { Crpcclient } from \"./rpcclient.js\";\nimport { rpcStatus } from \"./rpcstatus.js\";\nimport { dispatcher } from \"../dispatcher/dispatcher.js\";\n//import * as utils from \"../Utils/util.js\";\nimport { CrpCaller } from \"./rpcCaller.js\";\nimport { CaccessRpcResponse } from \"./rpcaccessResponse.js\";\nimport { dBError } from \"../exception/errorMessages.js\";\nimport * as utils from \"../Utils/util.js\";\n//import { util } from \"webpack\";\n\nexport class CRpc { \n\n  constructor(dbcorelib) {\n    this._dbcore = dbcorelib;\n    this.cf = new Crpcclient(this._dbcore);\n    this._serverName_sid = new Map();\n    this._serverSid_registry = new Map();\n    this._dispatch = new dispatcher();\n    this._callersid_object = new Map(); \n    this._server_type = [\"pvt\", \"prs\", \"sys\"]; \n  }\n\n  isEmptyOrSpaces(str) {\n    return str === null || (/^ *$/).test(str);\n  }\n  \n  _validateServerName(serverName, mtype = 0) {\n    if (this.isEmptyOrSpaces(serverName)) {\n      if (mtype == 1) {\n        throw (new dBError(\"E048\"));\n      }\n    }\n    \n    if (serverName.length > 64) {\n      if (mtype == 1) {\n        throw (new dBError(\"E051\"));\n      }\n    } \n    \n    if (!(/^[a-zA-Z0-9.:_-]*$/.test(serverName))) {\n      if (mtype == 1) {\n        throw (new dBError(\"E052\"));\n      }\n    }\n    \n    if (serverName.includes(\":\")) {\n      var sdata = serverName.toLowerCase().split(\":\");\n      if (!this._server_type.includes(sdata[0])) {\n        if (mtype == 1) {\n          throw (new dBError(\"E052\"));\n        }\n      }\n    }\n  }\n  \n  _get_rpcStatus(sid) { \n    return this._serverSid_registry.get(sid).status;\n  }\n  \n  bind(eventName, callback) {\n  \n    this._dispatch.bind(eventName, callback);\n  }\n  \n  unbind(eventName, callback) {\n    this._dispatch.unbind(eventName, callback);\n  }\n  \n  bind_all(callback) {\n    this._dispatch.bind_all(callback);\n  }\n  \n  unbind_all(callback) {\n    this._dispatch.unbind_all(callback);\n  }\n  \n  _ReSubscribeAll() {\n    const _communicateR = async (serverName, sid, access_token) => {\n      let cStatus = false;\n      cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.CONNECT_TO_RPC_SERVER, serverName, sid, access_token);\n      if (!cStatus) {\n        throw (new dBError(\"E053\")); \n      }\n    };\n    \n    const _ReSubscribe = async (sid) => {\n      let m_object = this._serverSid_registry.get(sid);\n      let access_token = undefined; \n      const mprivate = this.isPrivateChannel(m_object.name);\n\n      switch (m_object.status) { \n      case rpcStatus.RPC_CONNECTION_ACCEPTED:\n        try {\n          if (!mprivate) {\n            _communicateR(m_object.name, sid, access_token);\n          } else {\n            const response = new CaccessRpcResponse(m_object.name, sid, this);\n            this._dbcore._accesstoken_dispatcher(m_object.name, utils.accessTokenActions.RPCCONNECT, response);\n          }\n        } catch (error) {\n          this._handleRegisterEvents([utils.systemEvents.RPC_CONNECT_FAIL], error, m_object);\n          return;\n        }\n        break;\n      }\n    };\n    this._serverName_sid.forEach((sidmap, key) => {\n      sidmap.forEach((value, sid) => {\n        _ReSubscribe(sid);\n      });\n    });\n  } \n\n  _handledispatcherEvent(eventName, serverName) {\n    this._dispatch.emit(eventName, serverName);\n    let sidmap = this._serverName_sid.get(serverName);\n    sidmap.forEach((value, sid) => {\n      let m_object = this._serverSid_registry.get(sid);\n      if (!m_object) return;\n      m_object.ino.emit(eventName, serverName);\n    });\n  } \n\n  _handleRegisterEvents(eventName, eventData, m_object) {\n    const dispatchEvents = async (i) => {\n      let metadata = { \"servername\": m_object.ino.getServerName(), \"eventname\": eventName[i] };\n\n      this._dispatch.emit_channel(eventName[i], eventData, metadata);\n      m_object.ino.emit(eventName[i], eventData, metadata);\n      i = i + 1;\n      if (i < eventName.length) {\n        dispatchEvents(i);\n      }\n    };\n    if (eventName.length > 0) {\n      dispatchEvents(0);\n    }\n  }\n\n  _handleRegisterEventsOld(eventName, eventData, m_object) {\n    const dispatchEvents = async (i) => {\n      m_object.ino.emit(eventName[i], eventData, m_object.ino.getServerName());\n      this._handledispatcherEvent(eventName[i], eventData, m_object.ino.getServerName());\n      i = i + 1;\n      if (i < eventName.length) {\n        dispatchEvents(i);\n      }\n    };\n    if (eventName.length > 0) {\n      dispatchEvents(0);\n    }\n  }\n  _updateRegistrationStatus(sid, status, reason) {\n    if (!this._serverSid_registry.has(sid)) return;\n    let m_object = this._serverSid_registry.get(sid);\n\n    switch (m_object.type) {\n    case \"r\":\n      switch (status) {\n      case rpcStatus.REGISTRATION_ACCEPTED:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(true);\n        this._handleRegisterEvents([utils.systemEvents.REGISTRATION_SUCCESS, utils.systemEvents.SERVER_ONLINE], \"\", m_object);\n        break;\n      default:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(false);\n        this._handleRegisterEvents([utils.systemEvents.REGISTRATION_FAIL], reason, m_object);\n        this._serverName_sid.get(m_object.name).delete(sid);\n        this._serverSid_registry.delete(sid);\n\n        break;\n\n      }\n      break;\n    case \"c\":\n      switch (status) {\n      case rpcStatus.RPC_CONNECTION_ACCEPTED:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(true);\n        this._handleRegisterEvents([utils.systemEvents.RPC_CONNECT_SUCCESS, utils.systemEvents.SERVER_ONLINE], \"\", m_object);\n        break;\n      default:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(false);\n        this._handleRegisterEvents([utils.systemEvents.RPC_CONNECT_FAIL], reason, m_object);\n        this._serverName_sid.get(m_object.name).delete(sid);\n        this._serverSid_registry.delete(sid);\n\n        break;\n\n      }\n      break;\n    default:\n      break;\n    }\n\n  } \n\n\n  _updateRegistrationStatusRepeat(sid, status, reason) {\n    if (!this._serverSid_registry.has(sid)) return;\n    let m_object = this._serverSid_registry.get(sid);\n\n    switch (m_object.type) {\n    case \"r\":\n      switch (status) {\n      case rpcStatus.REGISTRATION_ACCEPTED:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(true);\n        this._handleRegisterEvents([utils.systemEvents.SERVER_ONLINE], \"\", m_object);\n        break;\n      default:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(false);\n        this._handleRegisterEvents([utils.systemEvents.SERVER_OFFLINE], reason, m_object);\n        break;\n\n      }\n      break;\n    case \"c\":\n      switch (status) {\n      case rpcStatus.RPC_CONNECTION_ACCEPTED:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(true);\n        this._handleRegisterEvents([utils.systemEvents.SERVER_ONLINE], \"\", m_object);\n        break;\n      default:\n        this._serverSid_registry.get(sid).status = status;\n        m_object.ino._set_isOnline(false);\n        this._handleRegisterEvents([utils.systemEvents.SERVER_OFFLINE], reason, m_object);\n        break;\n\n      }\n      break;\n    default:\n      break;\n    } \n  } \n\n  _updateRegistrationStatusAddChange(life_cycle, sid, status, reason) {\n    if (life_cycle == 0)  // first time subscription \n    { \n      this._updateRegistrationStatus(sid, status, reason);\n    } else { // resubscribe due to network failure \n      this._updateRegistrationStatusRepeat(sid, status, reason);\n    }\n  }\n\n\n  isPrivateChannel(serverName) {\n    let flag = false;\n    if (serverName.includes(\":\")) {\n      var sdata = serverName.toLowerCase().split(\":\");\n      if (this._server_type.includes(sdata[0])) {\n        flag = true;\n      } else {\n        flag = false;\n      }\n    }\n    return flag;\n\n  }\n\n\n  _communicate(serverName, mprivate, action) {\n    let cStatus = false; \n    let m_value = undefined;\n    let access_token = null;\n    let sid = utils.GenerateUniqueId();\n\n    if (!mprivate) {\n      cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.CONNECT_TO_RPC_SERVER, serverName, sid, access_token);\n      if (!cStatus) throw (new dBError(\"E053\"));\n\n    } else { \n      const response = new CaccessRpcResponse(serverName, sid, this);\n      this._dbcore._accesstoken_dispatcher(serverName, action, response);\n    }\n\n    let rpccaller = new CrpCaller(serverName, this._dbcore, this);\n\n    m_value = { \"name\": serverName, \"type\": \"c\", \"status\": rpcStatus.RPC_CONNECTION_INITIATED, \"ino\": rpccaller };\n    if (this._serverName_sid.has(serverName)) {\n      this._serverName_sid.get(serverName).set(sid, null);\n    } else {\n      this._serverName_sid.set(serverName, new Map());\n      this._serverName_sid.get(serverName).set(sid, null);\n    }\n    this._serverSid_registry.set(sid, m_value);\n\n\n    return rpccaller;\n  }\n\n\n\n  _verify_acccess_response(access_object) { \n    let merror = \"\"; \n    if (!(\"statuscode\" in access_object)) {\n      merror = \"the return object structure is blank, does not contain statuscode key\";\n      return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n    } \n    if ((typeof access_object.statuscode != \"number\")) {\n      merror = \"the return object structure is blank, statuscode vaule must be numeric\";\n      return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n    } \n    if (access_object.statuscode != 0) {\n      if (!(\"error_message\" in access_object)) {\n        merror = \"access_token function return statuscode: \" + access_object.statuscode + \" error_message tag missing\";\n      } else {\n        merror = access_object.error_message;\n      }\n      return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n    }\n\n    if (!(\"accesskey\" in access_object)) {\n      merror = \"access_token function return statuscode: \" + access_object.statuscode + \" accesskey tag missing\";\n      return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n    }\n    if (!access_object.accesskey) {\n      merror = \"access_token function return statuscode: \" + access_object.statuscode + \" accesskey is blank\";\n      return { \"result\": false, \"msg\": merror, \"token\": \"\" };\n    }\n\n\n    return { \"result\": true, \"msg\": \"\", \"token\": access_object.accesskey };\n  }\n\n  _failure_dispatcher(sid, reason) {\n    let dberror = undefined;\n    const m_object = this._serverSid_registry.get(sid);\n    m_object.ino._set_isOnline(false); \n    dberror = new dBError(\"E104\");\n    dberror.updatecode(\"\", reason); \n    this._handleRegisterEvents([utils.systemEvents.RPC_CONNECT_FAIL], dberror, m_object);\n\n    this._serverName_sid.get(m_object.name).delete(sid);\n    this._serverSid_registry.delete(sid);\n  }\n  _send_to_dbr(serverName, sid, access_data) {\n    let cStatus = undefined;\n\n    let v_result = this._verify_acccess_response(access_data);\n    if (!v_result.result) {\n      this._failure_dispatcher(sid, v_result.msg);\n      return;\n    }\n    let access_token = v_result.token; \n    cStatus = utils.updatedBNewtworkSC(this._dbcore, MessageTypes.CONNECT_TO_RPC_SERVER, serverName, sid, access_token); \n    if (!cStatus) {\n      this._failure_dispatcher(sid, \"library is not connected with the dbridges network\");\n    }\n\n  }\n\n  connect(serverName) {\n    try {\n      this._validateServerName(serverName, 1);\n    } catch (error) {\n      throw (error);\n    } \n    const mprivate = this.isPrivateChannel(serverName); \n    let m_caller = undefined; \n    try {\n      m_caller = this._communicate(serverName, mprivate, utils.accessTokenActions.RPCCONNECT);\n    } catch (error) {\n      throw (error);\n    }\n    return m_caller;\n  }\n\n  ChannelCall(channelName) {\n\n    if (this._serverName_sid.has(channelName)) {\n      let sid = [... this._serverName_sid.get(channelName).keys()][0];\n      let mobject = this._serverSid_registry.get(sid);\n      //this._serverSid_registry.get(sid).count = mobject.count + 1;\n      return mobject.ino;\n    }\n    let sid = utils.GenerateUniqueId();\n    let rpccaller = new CrpCaller(channelName, this._dbcore, this, \"ch\");\n    this._serverName_sid.set(channelName, new Map());\n    this._serverName_sid.get(channelName).set(sid, null);\n    let m_value = { \"name\": channelName, \"type\": \"x\", \"status\": rpcStatus.RPC_CONNECTION_INITIATED, \"ino\": rpccaller, \"count\": 1 };\n    this._serverSid_registry.set(sid, m_value);\n    return rpccaller;\n\n       \n  }\n\n  /*ClearChannel(channelName) {\n    if (!this._serverName_sid.has(channelName)) return;\n    let sid = this._serverName_sid.get(channelName); \n    if (this._serverSid_registry.get(sid).count == 1) {\n      this._serverName_sid.delete(channelName);\n      this._serverSid_registry.delete(sid);\n    } else {\n      let mobject = this._serverSid_registry.get(sid);\n      this._serverSid_registry.get(sid).count = mobject.count - 1;\n    }\n  }*/\n\n  store_object(sid, rpccaller) {\n    this._callersid_object.set(sid, rpccaller);\n  }\n\n  delete_object(sid) {\n    this._callersid_object.delete(sid);\n  }\n\n  get_object(sid) {\n    if (this._callersid_object.has(sid)) return this._callersid_object.get(sid);\n\n  }\n  \n  _send_OfflineEvents() {\n    this._serverName_sid.forEach((sidmap, key) => {\n      sidmap.forEach((svalue, sid) => {\n        let value = this._serverSid_registry.get(sid);\n        value.ino._set_isOnline(false);\n        this._handleRegisterEvents([utils.systemEvents.SERVER_OFFLINE], \"\", value);\n      });\n    }); \n  }\n\n  cleanUp_All() {\n    const clean_channel = (sid) => {\n      return new Promise(resolve => {\n        let mobject = this._serverSid_registry.get(sid);\n        mobject.ino.unbind();\n        resolve();\n      });\n    };    \n    this._serverName_sid.forEach((sidmap, key) => {\n      sidmap.forEach((svalue, sid) => {\n        clean_channel(sid).then(() => {\n          this._serverSid_registry.delete(sid);\n        });\n      });\n      this._serverName_sid.delete(key);\n    });\n  }\n\n} ","/* eslint-disable no-async-promise-executor */\n/* eslint-disable no-undef */\n/* eslint-disable linebreak-style */\r\n\r\n/*\r\n\tDataBridges JavaScript client Library for browsers\r\n\thttps://www.databridges.io/\r\n\r\n\r\n\r\n\tCopyright 2022 Optomate Technologies Private Limited.\r\n\r\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\r\n\tyou may not use this file except in compliance with the License.\r\n\tYou may obtain a copy of the License at\r\n\r\n\t    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\tUnless required by applicable law or agreed to in writing, software\r\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\r\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\tSee the License for the specific language governing permissions and\r\n\tlimitations under the License.\r\n*/\r\n\r\n\r\n\"use strict\";\r\nimport { ConnectionState } from \"./Connection/ConectionState.js\";\r\nimport { Channels } from \"./channel/channels.js\";\r\nimport { states } from \"./Connection/states.js\";\r\nimport { MessageTypes } from \"./msgTypes/dBMessageTypes.js\";\r\nimport { channelStatus } from \"./channel/channelstatus.js\";\r\nimport { dispatcher } from \"./dispatcher/dispatcher.js\";\r\nimport { Crpcclient } from \"./rpc/rpcclient.js\";\r\nimport { CRpc } from \"./rpc/rpc.js\";\r\nimport { rpcStatus } from \"./rpc/rpcstatus.js\";\r\nimport { dBError } from \"./exception/errorMessages.js\";\r\n\r\n\r\n\r\nexport class dBridges {\r\n\r\n\r\n  constructor() {\r\n    this.appkey = undefined;\r\n    this.auth_url = undefined;\r\n    this._count = 0;\r\n    this._metadata = {\r\n      \"channelname\": undefined,\r\n      \"eventname\": undefined,\r\n      \"sourcesysid\": undefined,\r\n      \"sqnum\": undefined,\r\n      \"sessionid\": undefined,\r\n      \"intime\": undefined,\r\n    };\r\n    this._ClientSocket = undefined;\r\n    this._sessionid = undefined;\r\n    this.connectionstate = new ConnectionState(this);\r\n    this.channel = new Channels(this);\r\n    this._options = {};\r\n    \r\n    this.maxReconnectionRetries = 10;\r\n    this.maxReconnectionDelay = 120000;\r\n    this.minReconnectionDelay = 1000 + Math.random() * 4000;\r\n    this.reconnectionDelayGrowFactor = 1.3;\r\n    this.minUptime = 500;\r\n    this.connectionTimeout = 10000;\r\n    this.autoReconnect = true;\r\n\r\n    this._uptimeTimeout = undefined;\r\n    this._retryCount = 0;\r\n    \r\n    this._lifeCycle = 0;\r\n    this._isServerReconnect = false;\r\n    this._disconnect_reason=\"\";\r\n    this._dispatch = new dispatcher();\r\n    this.cf = new Crpcclient(this);\r\n    this.rpc = new CRpc(this);\r\n  }\r\n\r\n  get sessionid() {\r\n    return this._sessionid;\r\n  }\r\n\r\n\r\n  access_token(callback) {\r\n    if (!(callback)) throw (new dBError(\"E004\"));\r\n    if (!(typeof callback === \"function\")) throw (new dBError(\"E004\"));\r\n\r\n    if (!this._dispatch.isExists(\"dbridges:access_token\")) {\r\n      this._dispatch.bind(\"dbridges:access_token\", callback);\r\n    } else {\r\n      throw (new dBError(\"E004\"));\r\n    }\r\n  }\r\n\r\n\r\n  _accesstoken_dispatcher(channelName, action, response) {\r\n    if (this._dispatch.isExists(\"dbridges:access_token\")) {\r\n      this._dispatch.emit2(\"dbridges:access_token\", channelName, this._sessionid, action, response);\r\n    } else {\r\n      throw (new dBError(\"E004\"));\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  _acceptOpen() {\r\n    this._retryCount = 0;\r\n    this.connectionstate.reconnect_attempt = this._retryCount;\r\n    if (this._ClientSocket.connected) {\r\n      if (this._lifeCycle == 0) {\r\n        this.connectionstate._handledispatcher(states.CONNECTED);\r\n        this._lifeCycle++;\r\n      } else {\r\n        this.connectionstate._handledispatcher(states.RECONNECTED);\r\n      }\r\n    }\r\n  }\r\n\r\n    _getNextDelay = () => {\r\n      let delay = 0;\r\n      if (this._retryCount > 0) {\r\n        delay =\r\n                this.minReconnectionDelay * Math.pow(this.reconnectionDelayGrowFactor, this._retryCount - 1);\r\n        delay = (delay > this.maxReconnectionDelay) ? this.maxReconnectionDelay : delay;\r\n        delay = (delay < this.minReconnectionDelay) ? this.minReconnectionDelay : delay;\r\n      }\r\n      return delay;\r\n    }\r\n\r\n    _wait() {\r\n      return new Promise(resolve => {\r\n        setTimeout(resolve, this._getNextDelay());\r\n      });\r\n    }\r\n\r\n\r\n    _reconnect = async () => {\r\n\r\n      if (this._retryCount >= this.maxReconnectionRetries) {\r\n        this.connectionstate._handledispatcher(states.RECONNECT_FAILED, new dBError(\"E060\"));\r\n        \r\n        if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n        this.channel.cleanUp_All();\r\n        this.rpc.cleanUp_All();\r\n        //this.connectionstate.state = \"\";\r\n        this._lifeCycle =  0;\r\n        this._retryCount = 0;\r\n        this.connectionstate.set_newLifeCycle(true);\r\n        this.connectionstate._handledispatcher(states.DISCONNECTED);\r\n        return;\r\n      }\r\n      this._retryCount++;\r\n      this._wait()\r\n        .then(() => {\r\n          this.connectionstate.reconnect_attempt = this._retryCount;\r\n          this.connectionstate._handledispatcher(states.RECONNECTING, {});\r\n          this.connect();\r\n        });\r\n    }\r\n\r\n    shouldRestart(ekey) {\r\n      if (this.autoReconnect) {\r\n        if (!this.connectionstate.get_newLifeCycle()) {\r\n          if (typeof ekey === \"string\") {\r\n            this.connectionstate._handledispatcher(states.RECONNECT_ERROR, new dBError(ekey));\r\n          } else {\r\n            this.connectionstate._handledispatcher(states.RECONNECT_ERROR, ekey);\r\n          }\r\n          this._reconnect();\r\n          return;\r\n        } else {\r\n          if (typeof ekey === \"string\") {\r\n            this.connectionstate._handledispatcher(states.ERROR, new dBError(ekey));\r\n          } else {\r\n            this.connectionstate._handledispatcher(states.ERROR, ekey);\r\n          }\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    disconnect() {\r\n      this._ClientSocket.disconnect();\r\n    }\r\n\r\n\r\n\r\n    connect = async () => {\r\n\r\n      if(this._retryCount == 0  && !this.connectionstate.get_newLifeCycle())\r\n      {\r\n        this.connectionstate.set_newLifeCycle(true);\r\n      }\r\n      \r\n      if (!this.auth_url) {\r\n        if (this.connectionstate.get_newLifeCycle()) {\r\n          throw (new dBError(\"E001\"));\r\n        } else {\r\n          this.shouldRestart(\"E001\");\r\n          return;\r\n        }\r\n      }\r\n\r\n\r\n\r\n      if (!this.appkey) {\r\n\r\n        if (this.connectionstate.get_newLifeCycle()) {\r\n          throw (new dBError(\"E002\"));\r\n        } else {\r\n          this.shouldRestart(\"E002\");\r\n          return;\r\n\r\n        }\r\n      }\r\n\r\n\r\n\r\n      try {\r\n        this.cf._verify_function();\r\n      } catch (error) {\r\n        if (this.connectionstate.get_newLifeCycle()) {\r\n          throw (error);\r\n        } else {\r\n          this.shouldRestart(error);\r\n          return;\r\n        }\r\n      }\r\n\r\n      let jdata = undefined;\r\n      try {\r\n        jdata = await this.GetdBRInfo(this.auth_url, this.appkey);\r\n      } catch (error) {\r\n        if (this.connectionstate.get_newLifeCycle()) {\r\n          throw (error);\r\n        } else {\r\n          this.shouldRestart(error);\r\n          return;\r\n\r\n        }\r\n      }\r\n\r\n      if (!jdata) {\r\n\r\n        this.shouldRestart(\"E008\", [this.auth_url]);\r\n        return;\r\n      }\r\n\r\n\r\n      let secure = jdata.secured;\r\n\r\n      let protocol = (secure) ? \"https://\" : \"http://\";\r\n      let dbripport = protocol + jdata.wsip + \":\" + jdata.wsport;\r\n\r\n\r\n      this._options[\"query\"] = {\r\n        \"sessionkey\": jdata.sessionkey,\r\n        \"version\": \"1.1\",\r\n        \"libtype\": \"javascript\",\r\n        \"cf\": this.cf.enable\r\n      };\r\n\r\n      this._options.secure = !(\"secure\" in this._options) ? true : true;\r\n      this._options.rejectUnauthorized = !(\"rejectUnauthorized\" in this._options) ? false : false;\r\n\r\n      this._options.retryInterval = !(\"retryInterval\" in this._options) ? 5 : 5;\r\n      this._options.retryAttempt = !(\"retryAttempt\" in this._options) ? 0 : 0;\r\n      this._options.reconnect = !(\"reconnect\" in this._options) ? false : false;\r\n\r\n      this._options[\"transports\"] = [\"websocket\"];\r\n      this._options[\"timeout\"] = (this.connectionTimeout <= 0) ? 20000 : this.connectionTimeout;\r\n\r\n      if (this._lifeCycle == 0) {\r\n        this.connectionstate._handledispatcher(states.CONNECTING, {});\r\n      }\r\n      this._isServerReconnect = false;\r\n      this._disconnect_reason = \"\";\r\n      this.connectionstate.set_newLifeCycle(true);\r\n\r\n      // try{\r\n      this._ClientSocket = io.connect(dbripport, this._options);\r\n      this._ClientSocket.addEventListener(\"disconnect\", this._IOEventReconnect);\r\n      this._ClientSocket.addEventListener(\"db\", this._IOMessage);\r\n      this._ClientSocket.addEventListener(\"connect\", this._IOConnect);\r\n      this._ClientSocket.addEventListener(\"connect_timeout\", this._IOConnectFailed);\r\n      this._ClientSocket.addEventListener(\"connect_error\", this._IOError);\r\n      window.addEventListener(\"offline\" ,  ()=>{\r\n        //this._IOEventReconnect(\"navigator.offline\");\r\n        this._isServerReconnect =  true;\r\n        this._disconnect_reason = \"navigator.offline\";\r\n        this._ClientSocket.disconnect();\r\n      });\r\n      //}catch(error){\r\n      //  throw error;\r\n      // }\r\n    }\r\n\r\n\r\n\r\n    GetdBRInfo = (url, api_key) => {\r\n      return new Promise(async (resolve, reject) => {\r\n\r\n        try {\r\n          const response = await fetch(url, {\r\n            method: \"POST\",\r\n            headers: {\r\n              \"Content-Type\": \"application/json\",\r\n              \"x-api-key\": api_key,\r\n              \"lib-transport\": \"sio\",\r\n            },\r\n            agent: this.httpsAgent,\r\n            body: \"{}\"\r\n          });\r\n          if (response.status != 200) {\r\n            let db = new dBError(\"E006\", [response.status, response.statusText]);\r\n            db.updatecode(response.status, \"\");\r\n            reject(db);\r\n          }\r\n          let jdata = await response.json();\r\n          resolve(jdata);\r\n\r\n        } catch (error) {\r\n          let db = new dBError(\"E008\", [error.code, error.message]);\r\n          db.updatecode(error.code, \"\");\r\n          reject(db);\r\n        }\r\n      });\r\n    }\r\n\r\n    _IOEventReconnect = (reason) => {\r\n      this.channel._send_OfflineEvents();\r\n      this.rpc._send_OfflineEvents();\r\n      switch (reason) {\r\n      case \"io server disconnect\":\r\n        this.connectionstate._handledispatcher(states.ERROR, new dBError(\"E061\"));\r\n        if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n        if (!this.autoReconnect) {\r\n          \r\n          this.channel.cleanUp_All();\r\n          this.rpc.cleanUp_All();\r\n          //this.connectionstate.state = \"\";\r\n          this._lifeCycle =  0;\r\n          this._retryCount = 0;\r\n          this.connectionstate.set_newLifeCycle(true);\r\n          this.connectionstate._handledispatcher(states.DISCONNECTED);\r\n        }else{\r\n          this._reconnect();\r\n        }\r\n\r\n        break;\r\n      case \"io client disconnect\":\r\n        if (this._isServerReconnect) {\r\n\r\n          if(this._disconnect_reason == \"navigator.offline\"){\r\n            let dberr = new dBError(\"E063\");\r\n            dberr.updatecode(null, \"BROWSER_NAVIGATOR_OFFLINE\");\r\n            this.connectionstate._handledispatcher(states.CONNECTION_BREAK, dberr);\r\n            \r\n          }else{\r\n            this.connectionstate._handledispatcher(states.CONNECTION_BREAK, new dBError(\"E062\"));\r\n          }\r\n          \r\n          if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n          if (!this.autoReconnect) {\r\n            \r\n            this.channel.cleanUp_All();\r\n            this.rpc.cleanUp_All();\r\n            //this.connectionstate.state = \"\";\r\n            this._lifeCycle =  0;\r\n            this._retryCount = 0;\r\n            this.connectionstate.set_newLifeCycle(true);\r\n            this.connectionstate._handledispatcher(states.DISCONNECTED);\r\n          }else{\r\n            this._reconnect();\r\n          }\r\n\r\n        } else {\r\n          //this.connectionstate._handledispatcher(states.ERROR, new dBError(\"E063\"));\r\n          \r\n          if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n          this.channel.cleanUp_All();\r\n          this.rpc.cleanUp_All();\r\n          //this.connectionstate.state = \"\";\r\n          this._lifeCycle =  0;\r\n          this._retryCount = 0;\r\n          this.connectionstate.set_newLifeCycle(true);\r\n          this.connectionstate._handledispatcher(states.DISCONNECTED );\r\n        }\r\n\r\n        break;\r\n\r\n      default:\r\n        if (this._uptimeTimeout) clearTimeout(this._uptimeTimeout);\r\n\r\n        this.connectionstate._handledispatcher(states.CONNECTION_BREAK, new dBError(\"E063\"));\r\n        if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n        if (!this.autoReconnect) {\r\n         \r\n          this.channel.cleanUp_All();\r\n          this.rpc.cleanUp_All();\r\n          //this.connectionstate.state = \"\";\r\n          this._lifeCycle =  0;\r\n          this._retryCount = 0;\r\n          this.connectionstate.set_newLifeCycle(true);\r\n          this.connectionstate._handledispatcher(states.DISCONNECTED);\r\n        }else{\r\n          this._reconnect();\r\n        }\r\n        break;\r\n\r\n      }\r\n\r\n    }\r\n\r\n\r\n    _ReplyLatency = (recdlatency, oqueumonitorid) => {\r\n      if (this._ClientSocket.connected) {\r\n        this._ClientSocket.emit(\"db\", MessageTypes.LATENCY, null, null, null, null, null, null, null, null, null, recdlatency, null, null, null, true, oqueumonitorid);\r\n      }\r\n    }\r\n\r\n\r\n    _Rttpong = (dbmsgtype, subject, rsub, sid, payload, fenceid,\r\n      rspend, rtrack, rtrackstat, t1, latency, globmatch,\r\n      sourceid, sourceip, replylatency, oqueumonitorid) => {\r\n      if (this._ClientSocket.connected) {\r\n        this._ClientSocket.emit(\"db\", dbmsgtype, subject, rsub, sid, payload, fenceid,\r\n          rspend, rtrack, rtrackstat, t1, latency, globmatch,\r\n          sourceid, sourceip, replylatency, oqueumonitorid);\r\n      }\r\n    }\r\n\r\n\r\n\r\n\r\n    _mBufferToString = (buffer) => {\r\n      if (buffer) {\r\n        const decoder = new TextDecoder();\r\n        return decoder.decode(buffer);\r\n      }\r\n      return \"\";\r\n    }\r\n\r\n\r\n    _IOMessage = (dbmsgtype, subject, rsub, sid, payload, fenceid,\r\n      rspend, rtrack, rtrackstat, t1, latency, globmatch,\r\n      sourceid, sourceip, replylatency, oqueumonitorid) => {\r\n\r\n      let mchannelName = undefined;\r\n      let metadata = undefined;\r\n      const recieved = new Date().getTime(); \r\n      let recdDate = (t1) ? Number(t1) : 0;\r\n      const lib_latency = recieved - recdDate;\r\n      \r\n      let dberr = undefined;\r\n      let rpccaller = undefined;\r\n      let extradata = undefined;\r\n      let mpayload = undefined;\r\n      \r\n      switch (dbmsgtype) {\r\n\r\n      case MessageTypes.SYSTEM_MSG:\r\n        switch (subject) {\r\n        case \"connection:success\":\r\n          this._sessionid = this._mBufferToString(payload);\r\n\r\n          if (this.connectionstate.get_newLifeCycle()) {\r\n            if (this.cf.enable) {\r\n              this.cf.functions(); //executing \r\n            }\r\n          }\r\n\r\n          this.connectionstate.set_newLifeCycle(false);\r\n          this._uptimeTimeout = setTimeout(() => this._acceptOpen(), (this.minUptime < 0) ? 5000 : this.minUptime);\r\n          \r\n          this.rpc._ReSubscribeAll();\r\n          this.channel._ReSubscribeAll();\r\n\r\n          if (t1) {\r\n            this._Rttpong(dbmsgtype, \"rttpong\", rsub, sid, payload, fenceid,\r\n              rspend, rtrack, rtrackstat, t1, lib_latency, globmatch,\r\n              sourceid, sourceip, replylatency, oqueumonitorid);\r\n          }\r\n\r\n\r\n          break;\r\n\r\n        case \"rttping\":\r\n\r\n          if (t1) {\r\n            this.connectionstate._rttms = lib_latency;\r\n\r\n            this._Rttpong(dbmsgtype, \"rttpong\", rsub, sid, payload, fenceid,\r\n              rspend, rtrack, rtrackstat, t1, lib_latency, globmatch,\r\n              sourceid, sourceip, replylatency, oqueumonitorid);\r\n          }\r\n\r\n          break;\r\n\r\n        case \"rttpong\":\r\n          if (t1) {\r\n            const now = new Date();\r\n            const eventData = now.getTime() - Number(t1);\r\n            this.connectionstate._rttms = lib_latency;\r\n            this.connectionstate._handledispatcher(states.RTTPONG, eventData);\r\n          }\r\n          break;\r\n        case \"reconnect\":\r\n          // nned to check \r\n          this._isServerReconnect = true;\r\n          this._ClientSocket.disconnect();\r\n          break;\r\n\r\n        default: //fail:access_denied fail:error\r\n          dberr = new dBError(\"E082\");\r\n          dberr.updatecode(subject, this._mBufferToString(payload));\r\n          this.connectionstate._handledispatcher(states.ERROR, dberr);\r\n          break;\r\n        }\r\n\r\n        break;\r\n      case MessageTypes.SUBSCRIBE_TO_CHANNEL:\r\n        switch (subject) {\r\n        case \"success\":\r\n          switch (this.channel._get_subscribeStatus(sid)) {\r\n          case channelStatus.SUBSCRIPTION_INITIATED:\r\n            this.channel._updateChannelsStatusAddChange(0, sid, channelStatus.SUBSCRIPTION_ACCEPTED, \"\");\r\n            break;\r\n          case channelStatus.SUBSCRIPTION_ACCEPTED:\r\n          case channelStatus.SUBSCRIPTION_PENDING:\r\n            this.channel._updateChannelsStatusAddChange(1, sid, channelStatus.SUBSCRIPTION_ACCEPTED, \"\");\r\n            break;\r\n          }\r\n          break;\r\n        default: //fail:access_denied fail:error\r\n          dberr = new dBError(\"E064\");\r\n          dberr.updatecode(subject.toUpperCase(), this._mBufferToString(payload));\r\n\r\n          switch (this.channel._get_subscribeStatus(sid)) {\r\n          case channelStatus.SUBSCRIPTION_INITIATED:\r\n            this.channel._updateChannelsStatusAddChange(0, sid, channelStatus.SUBSCRIPTION_ERRORs, dberr);\r\n            break;\r\n          case channelStatus.SUBSCRIPTION_ACCEPTED:\r\n          case channelStatus.SUBSCRIPTION_PENDING:\r\n            this.channel._updateChannelsStatusAddChange(1, sid, channelStatus.SUBSCRIPTION_PENDING, dberr);\r\n            break;\r\n          }\r\n          break;\r\n        }\r\n        break;\r\n      case MessageTypes.CONNECT_TO_CHANNEL:\r\n        switch (subject) {\r\n        case \"success\":\r\n\r\n          switch (this.channel._get_subscribeStatus(sid)) {\r\n          case channelStatus.CONNECTION_INITIATED:\r\n            this.channel._updateChannelsStatusAddChange(0, sid, channelStatus.CONNECTION_ACCEPTED, \"\");\r\n            break;\r\n          case channelStatus.CONNECTION_ACCEPTED:\r\n          case channelStatus.CONNECTION_PENDING:\r\n            this.channel._updateChannelsStatusAddChange(1, sid, channelStatus.CONNECTION_ACCEPTED, \"\");\r\n            break;\r\n          }\r\n          break;\r\n        default: //fail:access_denied fail:error \r\n          dberr = new dBError(\"E084\");\r\n          dberr.updatecode(subject.toUpperCase(), this._mBufferToString(payload));\r\n\r\n          switch (this.channel._get_subscribeStatus(sid)) {\r\n          case channelStatus.CONNECTION_INITIATED:\r\n            this.channel._updateChannelsStatusAddChange(0, sid, channelStatus.CONNECTION_ERROR, dberr);\r\n            break;\r\n          case channelStatus.CONNECTION_ACCEPTED:\r\n          case channelStatus.CONNECTION_PENDING:\r\n            this.channel._updateChannelsStatusAddChange(1, sid, channelStatus.CONNECTION_PENDING, dberr);\r\n            break;\r\n          }\r\n          break;\r\n        }\r\n        break;\r\n      case MessageTypes.UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL:\r\n        switch (subject) {\r\n        case \"success\":\r\n\r\n          switch (this.channel._get_channelType(sid)) {\r\n          case \"s\":\r\n            this.channel._updateChannelsStatusRemove(sid, channelStatus.UNSUBSCRIBE_ACCEPTED, \"\");\r\n            break;\r\n          case \"c\":\r\n            this.channel._updateChannelsStatusRemove(sid, channelStatus.DISCONNECT_ACCEPTED, \"\");\r\n            break;\r\n          }\r\n          break;\r\n        default: //fail:error\r\n          switch (this.channel._get_channelType(sid)) {\r\n          case \"s\":\r\n            dberr = new dBError(\"E065\");\r\n            dberr.updatecode(subject.toUpperCase(), this._mBufferToString(payload));\r\n\r\n            this.channel._updateChannelsStatusRemove(sid, channelStatus.UNSUBSCRIBE_ERROR, dberr);\r\n            break;\r\n          case \"c\":\r\n            dberr = new dBError(\"E088\");\r\n            dberr.updatecode(subject.toUpperCase(), this._mBufferToString(payload));\r\n            this.channel._updateChannelsStatusRemove(sid, channelStatus.DISCONNECT_ERROR, \"\");\r\n            break;\r\n          }\r\n          break;\r\n        }\r\n        break;\r\n\r\n      case MessageTypes.PUBLISH_TO_CHANNEL:\r\n        mchannelName = this.channel._get_channelName(sid);\r\n        metadata = Object.assign({}, this._metadata);\r\n        metadata.eventname = subject;\r\n        metadata.sourcesysid = sourceid;\r\n        metadata.sessionid = sourceip;\r\n        metadata.sqnum = oqueumonitorid;\r\n        if (t1) { metadata.intime = t1; }\r\n\r\n\r\n        if (mchannelName.toLowerCase().startsWith(\"sys:*\")) {\r\n          metadata.channelname = fenceid;\r\n        } else {\r\n          metadata.channelname = mchannelName;\r\n        }\r\n\r\n        mpayload = undefined;\r\n        try {\r\n          mpayload = (payload) ? this._mBufferToString(payload) : \"\";\r\n        } catch (error) {\r\n          mpayload = \"\";\r\n        }\r\n\r\n        this.channel._handledispatcherEvents(subject, mpayload, mchannelName, metadata);\r\n\r\n        break;\r\n      case MessageTypes.PARTICIPANT_JOIN:\r\n        mchannelName = this.channel._get_channelName(sid);\r\n        metadata = Object.assign({}, this._metadata);\r\n        metadata.eventname = \"dbridges:participant.joined\";\r\n        metadata.sourcesysid = sourceid;\r\n        metadata.sessionid = sourceip;\r\n        metadata.sqnum = oqueumonitorid;\r\n        metadata.channelname = mchannelName;\r\n        if (t1) { metadata.intime = t1; }\r\n\r\n        if (mchannelName.toLowerCase().startsWith(\"sys:\") || mchannelName.toLowerCase().startsWith(\"prs:\")) {\r\n          extradata = this._convertToObject(sourceip, sourceid, fenceid);\r\n          metadata.sourcesysid = extradata.sysyid;\r\n          metadata.sessionid = extradata.s;\r\n          if (mchannelName.toLowerCase().startsWith(\"sys::*\")) {\r\n            this.channel._handledispatcherEvents(\"dbridges:participant.joined\", extradata.i, mchannelName, metadata);\r\n          } else {\r\n            this.channel._handledispatcherEvents(\"dbridges:participant.joined\", extradata.i, mchannelName, metadata);\r\n          }\r\n        } else {\r\n          this.channel._handledispatcherEvents(\"dbridges:participant.joined\", { \"sourcesysid\": sourceid }, mchannelName, metadata);\r\n        }\r\n\r\n        break;\r\n\r\n      case MessageTypes.PARTICIPANT_LEFT:\r\n        mchannelName = this.channel._get_channelName(sid);\r\n\r\n        metadata = Object.assign({}, this._metadata);\r\n        metadata.eventname = \"dbridges:participant.left\";\r\n        metadata.sourcesysid = sourceid;\r\n        metadata.sessionid = sourceip;\r\n        metadata.sqnum = oqueumonitorid;\r\n        metadata.channelname = mchannelName;\r\n        if (t1) { metadata.intime = t1; }\r\n        if (mchannelName.toLowerCase().startsWith(\"sys:\") || mchannelName.toLowerCase().startsWith(\"prs:\")) {\r\n          extradata = this._convertToObject(sourceip, sourceid, fenceid);\r\n          metadata.sourcesysid = extradata.sysyid;\r\n          metadata.sessionid = extradata.s;\r\n          \r\n          if (mchannelName.toLowerCase().startsWith(\"sys:*\")) {\r\n            \r\n            //metadata.sessionid = extradata.s;\r\n\r\n            this.channel._handledispatcherEvents(\"dbridges:participant.left\", extradata.i, mchannelName, metadata);\r\n          } else {\r\n            this.channel._handledispatcherEvents(\"dbridges:participant.left\", extradata.i, mchannelName, metadata);\r\n          }\r\n        } else {\r\n          this.channel._handledispatcherEvents(\"dbridges:participant.left\", { \"sourcesysid\": sourceid }, mchannelName, metadata);\r\n        }\r\n\r\n        break;\r\n      case MessageTypes.CF_CALL_RECEIVED:\r\n        if (sid == 0) {\r\n          let mpayload = undefined;\r\n          try {\r\n            mpayload = (payload) ? this._mBufferToString(payload) : \"\";\r\n          } catch (error) {\r\n            mpayload = \"\";\r\n          }\r\n          this.cf._handle_dispatcher(subject, rsub, sid, mpayload);\r\n        }\r\n\r\n        break;\r\n      case MessageTypes.CF_RESPONSE_TRACKER:\r\n        //1. ERROR.CODE = rsub\r\n        //2. response.id =  subject\r\n        this.cf._handle_tracker_dispatcher(subject, rsub);\r\n        break;\r\n      case MessageTypes.CF_CALLEE_QUEUE_EXCEEDED:\r\n        this.cf._handle_exceed_dispatcher();\r\n        break;\r\n      case MessageTypes.CONNECT_TO_RPC_SERVER:\r\n        switch (subject) {\r\n        case \"success\":\r\n          switch (this.rpc._get_rpcStatus(sid)) {\r\n          case rpcStatus.RPC_CONNECTION_INITIATED:\r\n            this.rpc._updateRegistrationStatusAddChange(0, sid, rpcStatus.RPC_CONNECTION_ACCEPTED, \"\");\r\n            break;\r\n          case rpcStatus.RPC_CONNECTION_ACCEPTED:\r\n          case rpcStatus.RPC_CONNECTION_PENDING:\r\n            this.rpc._updateRegistrationStatusAddChange(1, sid, rpcStatus.RPC_CONNECTION_ACCEPTED, \"\");\r\n            break;\r\n          }\r\n          break;\r\n        default: //fail:access_denied fail:error\r\n          dberr = new dBError(\"E082\");\r\n          dberr.updatecode(subject.toUpperCase(), \"\");\r\n          switch (this.rpc._get_rpcStatus(sid)) {\r\n          case rpcStatus.RPC_CONNECTION_INITIATED:\r\n            this.rpc._updateRegistrationStatusAddChange(0, sid, rpcStatus.RPC_CONNECTION_ERROR, dberr);\r\n            break;\r\n          case rpcStatus.RPC_CONNECTION_ACCEPTED:\r\n          case rpcStatus.RPC_CONNECTION_PENDING:\r\n            this.rpc._updateRegistrationStatusAddChange(1, sid, rpcStatus.RPC_CONNECTION_PENDING, dberr);\r\n            break;\r\n          }\r\n          break;\r\n        }\r\n        break;\r\n      case MessageTypes.RPC_CALL_RESPONSE:\r\n        mpayload = \"\";\r\n        try {\r\n          mpayload = (payload) ? this._mBufferToString(payload) : \"\";\r\n        } catch (error) {\r\n          mpayload = \"\";\r\n        }\r\n        rpccaller = this.rpc.get_object(sid);\r\n        rpccaller._handle_callResponse(sid, mpayload, rspend, rsub);\r\n        break;\r\n\r\n      case MessageTypes.RPC_CALL_RECEIVED:\r\n\r\n        if (sid == 0) {\r\n          mpayload = undefined;\r\n          try {\r\n            mpayload = (payload) ? this._mBufferToString(payload) : \"\";\r\n          } catch (error) {\r\n            mpayload = \"\";\r\n          }\r\n          let caller = this.rpc.get_rpcServerObject(sid);\r\n          caller._handle_dispatcher(subject, rsub, sid, mpayload);\r\n        }\r\n        break;\r\n\r\n      case MessageTypes.RPC_RESPONSE_TRACKER:\r\n        //1. ERROR.CODE = rsub\r\n        //2. response.id =  subject\r\n        rpccaller = this.rpc.get_object(sid);\r\n        rpccaller._handle_tracker_dispatcher(subject, rsub);\r\n        break;\r\n      case MessageTypes.RPC_CALLEE_QUEUE_EXCEEDED:\r\n        rpccaller = this.rpc.get_object(sid);\r\n        rpccaller._handle_exceed_dispatcher();\r\n        break;\r\n\r\n\r\n\r\n      }\r\n    }\r\n\r\n    _convertToObject = (sourceip, sourceid, channelname = undefined) => {\r\n      let sessionid = \"\";\r\n      let libtype = \"\";\r\n      let sourceipv4 = \"\";\r\n      let sourceipv6 = \"\";\r\n      let sourcesysid = \"\";\r\n\r\n      if (sourceid) {\r\n        var strData = sourceid.split(\"#\");\r\n        if (strData.length > 1) sessionid = strData[0];\r\n        if (strData.length > 2) libtype = strData[1];\r\n        if (strData.length > 3) sourceipv4 = strData[2];\r\n        if (strData.length > 4) sourceipv6 = strData[3];\r\n        if (strData.length >= 5) sourcesysid = strData[4];\r\n      }\r\n\r\n      let inObject = (channelname) ? {\r\n        \"sessionid\": sessionid, \"libtype\": libtype,\r\n        \"sourceipv4\": sourceipv4, \"sourceipv6\": sourceipv6, \"sysinfo\": sourceip,\r\n        \"channelname\": channelname, \"sourcesysid\": sourcesysid\r\n      } : {\r\n        \"sessionid\": sessionid, \"libtype\": libtype,\r\n        \"sourceipv4\": sourceipv4, \"sourceipv6\": sourceipv6, \"sysinfo\": sourceip, \"sourcesysid\": sourcesysid\r\n      };\r\n\r\n      return { \"i\": inObject, \"s\": sessionid ,  \"sysyid\": sourcesysid};\r\n\r\n    }\r\n\r\n\r\n    _IOConnect = () => {\r\n      //this.connectionstate._handledispatcher(states.CONNECTED, {});\r\n      //this._ClientSocket.sendBuffer = [];\r\n    }\r\n\r\n    _IOConnectFailed = (info) => {\r\n\r\n      this.connectionstate._handledispatcher(states.ERROR, info);\r\n      if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n\r\n      if (this.autoReconnect) this._reconnect();\r\n    }\r\n\r\n    _IOError = (err) => {\r\n      this.connectionstate._handledispatcher(states.ERROR, err);\r\n      if (this._ClientSocket) this._ClientSocket.removeAllListeners();\r\n      if (this.autoReconnect) this._reconnect();\r\n\r\n    }\r\n\r\n\r\n    _isSocketConnected() {\r\n      return (this._ClientSocket) ? this._ClientSocket.connected : false;\r\n    }\r\n\r\n    send = (msgDbp) => {\r\n      let flag = false;\r\n      if (this._ClientSocket.connected) {\r\n        this._ClientSocket.emit(\r\n          msgDbp.eventname,\r\n          msgDbp.dbmsgtype,\r\n          msgDbp.subject,\r\n          msgDbp.rsub,\r\n          msgDbp.sid,\r\n          msgDbp.payload,\r\n          msgDbp.fenceid,\r\n          msgDbp.rspend,\r\n          msgDbp.rtrack,\r\n          msgDbp.rtrackstat,\r\n          msgDbp.t1,\r\n          msgDbp.latency,\r\n          msgDbp.globmatch,\r\n          msgDbp.sourceid,\r\n          msgDbp.sourceip,\r\n          msgDbp.replylatency,\r\n          msgDbp.oqueumonitorid\r\n        );\r\n        flag = true;\r\n      }\r\n      return flag;\r\n    }\r\n}\r\n"],"names":["errMsg","source_lookup","code_lookup","dBError","Error","constructor","ekey","elist","undefined","mflag","evalue","length","source","code","this","message","join","captureStackTrace","_EKEY","updatecode","charAt","getEKEY","dispatcher","_local_register","Map","_global_register","isExists","eventName","has","bind","callback","get","push","set","bind_all","unbind","forEach","ca","delete","unbind_all","emit2","channelName","sessionId","action","response","callbacks","i","emit_cf","functionName","inparameter","rsub","emit_connectionState","payload","metadata","global_registry_call","index","local_registry_call","emit_channel","emit_clientfunction","emit","EventInfo","states","Object","freeze","CONNECTED","ERROR","DISCONNECTED","RECONNECTING","CONNECTING","STATE_CHANGE","RECONNECT_ERROR","RECONNECT_FAILED","RECONNECTED","CONNECTION_BREAK","RTTPONG","RTTPING","utf8AbFromStr","str","encoder","TextEncoder","encode","updatedBNewtworkSC","dbcore","dbmsgtype","sid","channelToken","subject","source_id","t1","seqnum","msgDbp","send","updatedBNewtworkCF","sessionid","returnSubject","rspend","rtrack","GenerateUniqueId","Math","random","substring","systemEvents","SUBSCRIBE_SUCCESS","SUBSCRIBE_FAIL","ONLINE","OFFLINE","REMOVE","UNSUBSCRIBE_SUCCESS","UNSUBSCRIBE_FAIL","CONNECT_SUCCESS","CONNECT_FAIL","DISCONNECT_SUCCESS","DISCONNECT_FAIL","RESUBSCRIBE_SUCCESS","RESUBSCRIBE_FAIL","RECONNECT_SUCCESS","RECONNECT_FAIL","PARTICIPANT_JOINED","PARTICIPANT_LFET","REGISTRATION_SUCCESS","REGISTRATION_FAIL","SERVER_ONLINE","SERVER_OFFLINE","UNREGISTRATION_SUCCESS","UNREGISTRATION_FAIL","RPC_CONNECT_SUCCESS","RPC_CONNECT_FAIL","accessTokenActions","CHANNELSUBSCRIBE","CHANNELCONNECT","RPCCONNECT","RPCREGISTER","SYSTEM_CHANNELSUBSCRIBE","MessageTypes","SUBSCRIBE_TO_CHANNEL","CONNECT_TO_CHANNEL","UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL","PUBLISH_TO_CHANNEL","SERVER_SUBSCRIBE_TO_CHANNEL","SERVER_UNSUBSCRIBE_DISCONNECT_FROM_CHANNEL","SERVER_PUBLISH_TO_CHANNEL","SERVER_CHANNEL_SENDMSG","LATENCY","SYSTEM_MSG","PARTICIPANT_JOIN","PARTICIPANT_LEFT","CF_CALL_RECEIVED","CF_CALL","CF_CALL_RESPONSE","CF_CALL_TIMEOUT","CF_RESPONSE_TRACKER","CF_CALLEE_QUEUE_EXCEEDED","REGISTER_RPC_SERVER","UNREGISTER_RPC_SERVER","CONNECT_TO_RPC_SERVER","CALL_RPC_FUNCTION","CALL_CHANNEL_RPC_FUNCTION","RPC_CALL_RECEIVED","RPC_CALL_RESPONSE","RPC_CALL_TIMEOUT","RPC_RESPONSE_TRACKER","RPC_CALLEE_QUEUE_EXCEEDED","ConnectionState","dBCoreObject","_state","_isconnected","_NoChangeEvents","_supportedEvents","_registry","_newLifeCycle","reconnect_attempt","_dbcore","_rttms","value","rttping","now","Date","getTime","utils","set_newLifeCycle","get_newLifeCycle","includes","_updatestates","_handledispatcher","eventInfo","previous","leventInfo","channel","_channelName","_sid","_isOnline","getChannelName","isOnline","_set_isOnline","publish","eventData","toLowerCase","call","ttl","Promise","resolve","reject","startsWith","caller","rpc","ChannelCall","then","catch","error","connectSupportedEvents","channelnbd","_dispatch","channelStatus","SUBSCRIPTION_INITIATED","SUBSCRIPTION_PENDING","SUBSCRIPTION_ACCEPTED","SUBSCRIPTION_ERROR","CONNECTION_INITIATED","CONNECTION_PENDING","CONNECTION_ACCEPTED","CONNECTION_ERROR","UNSUBSCRIBE_INITIATED","UNSUBSCRIBE_ACCEPTED","UNSUBSCRIBE_ERROR","DISCONNECT_INITIATED","DISCONNECT_ACCEPTED","DISCONNECT_ERROR","CResponse","m_type","channels","_dbchannel","_mtype","end","data","_send_to_dbr","exception","info","Channels","_channel_type","_channelsid_registry","_channelname_sid","_metadata","_handledispatcherEvents","m_object","ino","isPrivateChannel","flag","sdata","split","_ReSubscribeAll","_communicateR","async","mtype","access_token","cStatus","_ReSubscribe","mprivate","name","status","m_actiontype","_accesstoken_dispatcher","_handleSubscribeEvents","key","isEmptyOrSpaces","test","_validateChanelName","error_type","connectionstate","isconnected","_communicate","m_channel","m_value","_verify_acccess_response","access_object","merror","statuscode","error_message","accesskey","_failure_dispatcher","reason","dberror","access_data","v_result","result","token","msg","subscribe","connect","unsubscribe","m_status","type","disconnect","dispatchEvents","assign","channelname","eventname","_updateSubscribeStatus","_updateSubscribeStatusRepeat","_updateChannelsStatusAddChange","life_cycle","_updateChannelsStatusRemove","_isonline","_isSocketConnected","list","m_data","i_data","_send_OfflineEvents","_get_subscribeStatus","_get_channelType","_get_channelName","getConnectStatus","getChannel","isSubscribedChannel","isSubscribed","cleanUp_All","clean_channel","mobject","CrpcResponse","returnSubect","dbcoreobject","_functionName","_returnSubsect","_isend","_id","tracker","next","expCode","expShortMessage","epayload","JSON","stringify","Crpcclient","enable","functions","_functionNames","_verify_function","regfn","unregfn","_handle_dispatcher","_handle_tracker_dispatcher","responseid","errorcode","_handle_exceed_dispatcher","err","resetqueue","rpcStatus","REGISTRATION_INITIATED","REGISTRATION_PENDING","REGISTRATION_ACCEPTED","REGISTRATION_ERROR","RPC_CONNECTION_INITIATED","RPC_CONNECTION_PENDING","RPC_CONNECTION_ACCEPTED","RPC_CONNECTION_ERROR","UNREGISTRATION_INITIATED","UNREGISTRATION_ACCEPTED","UNREGISTRATION_ERROR","RPC_DISCONNECT_INITIATED","RPC_DISCONNECT_ACCEPTED","RPC_DISCONNECT_ERROR","CrpcSResponse","CrpCaller","serverName","rpccoreobject","callertype","_rpccore","_sid_functionname","_serverName","_callerTYPE","getServerName","_handle_callResponse","isend","progress_callback","cstatus","eobject","toUpperCase","parse","c","m","_GetUniqueSid","nsid","ttlms","sid_created","loop_index","store_object","timer","race","_call_internal","_r","rej","setTimeout","clearTimeout","delete_object","CaccessRpcResponse","_dbrpc","CRpc","dbcorelib","cf","_serverName_sid","_serverSid_registry","_callersid_object","_server_type","_validateServerName","_get_rpcStatus","_handleRegisterEvents","sidmap","_handledispatcherEvent","_handleRegisterEventsOld","_updateRegistrationStatus","_updateRegistrationStatusRepeat","_updateRegistrationStatusAddChange","rpccaller","m_caller","keys","get_object","svalue","delay","_retryCount","minReconnectionDelay","pow","reconnectionDelayGrowFactor","maxReconnectionDelay","maxReconnectionRetries","_ClientSocket","removeAllListeners","_lifeCycle","_wait","auth_url","appkey","shouldRestart","jdata","GetdBRInfo","dbripport","secured","wsip","wsport","_options","sessionkey","secure","rejectUnauthorized","retryInterval","retryAttempt","reconnect","connectionTimeout","_isServerReconnect","_disconnect_reason","io","addEventListener","_IOEventReconnect","_IOMessage","_IOConnect","_IOConnectFailed","_IOError","window","url","api_key","fetch","method","headers","agent","httpsAgent","body","db","statusText","json","autoReconnect","_reconnect","dberr","_uptimeTimeout","recdlatency","oqueumonitorid","connected","fenceid","rtrackstat","latency","globmatch","sourceid","sourceip","replylatency","buffer","decoder","TextDecoder","decode","mchannelName","lib_latency","Number","extradata","mpayload","_sessionid","_mBufferToString","_acceptOpen","minUptime","_Rttpong","SUBSCRIPTION_ERRORs","sourcesysid","sqnum","intime","_convertToObject","sysyid","s","get_rpcServerObject","libtype","sourceipv4","sourceipv6","strData","_count","_getNextDelay"],"mappings":"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"}